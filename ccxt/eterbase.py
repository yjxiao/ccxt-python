# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import hashlib
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import InvalidOrder


class eterbase (Exchange):

    def describe(self):
        return self.deep_extend(super(eterbase, self).describe(), {
            'id': 'eterbase',
            'name': 'ETERBASE',
            'countries': ['SK'],
            'rateLimit': 500,
            'certified': False,
            'has': {
                'CORS': False,
                'publicAPI': True,
                'privateAPI': True,
                'cancelOrder': True,
                'createDepositAddress': False,
                'createOrder': True,
                'deposit': False,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': False,
                'fetchDepositAddress': False,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': False,
                'fetchOpenOrders': True,
                'fetchOrder': False,
                'fetchOrderBook': False,
                'fetchOrders': False,
                'fetchStatus': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchBidsAsks': False,
                'fetchTrades': True,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '1h': '60',
                '4h': '240',
                '1d': '1440',
                '1w': '10080',
            },
            'urls': {
                'logo': 'https://www.eterbase.com/wp-content/uploads/2019/09/Eterbase-Logo-Horizontal-1024x208.png',
                'base': 'https://api.eterbase.exchange',
                'api': 'https://api.eterbase.exchange/api',
                'www': 'https://www.eterbase.com',
                'doc': 'https://developers.eterbase.exchange',
                'fees': 'https://www.eterbase.com/exchange/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'ping',
                        'assets',
                        'markets',
                        'tickers',
                        'markets/{id}/trades',
                    ],
                },
                'private': {
                    'get': [
                        'accounts/{id}/balances',
                        'accounts/{id}/orders',
                        'accounts/{id}/fills',
                        'orders/{id}',
                    ],
                    'post': [
                        'orders',
                    ],
                    'delete': [
                        'orders/{id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'percentage': True,
                    'taker': 0.09,
                    'maker': 0.09,
                },
            },
            'options': {
                'createMarketBuyOrderRequiresPrice': True,
            },
        })

    def find_market(self, id):
        # need to pass identifier as string
        idString = str(id)
        return super(eterbase, self).find_market(idString)

    def sign(self, path, api='public', method='GET', params={}, httpHeaders=None, body=None):
        request = '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if method == 'GET':
            if query:
                request += '?' + self.urlencode(query)
        url = self.urls['api'] + request
        if api == 'private':
            self.check_required_credentials()
            payload = ''
            if method != 'GET':
                if query:
                    body = self.json(query)
                    payload = body
            # construct signature
            hasBody = (method == 'POST') or (method == 'PUT') or (method == 'PATCH')
            # date = 'Mon, 30 Sep 2019 13:57:23 GMT'
            date = self.rfc2616(self)
            urlBaselength = len(self.urls['base']) - 0
            urlPath = url[urlBaselength:]
            headersCSV = 'date' + ' ' + 'request-line'
            # eslint-disable-next-line quotes
            message = 'date' + ':' + ' ' + date + "\n" + method + ' ' + urlPath + ' HTTP/1.1'
            digest = ''
            if hasBody:
                digest = 'SHA-256=' + self.hash(payload, 'sha256', 'base64')
                # eslint-disable-next-line quotes
                message = message + "\ndigest" + ':' + ' ' + digest
                headersCSV = headersCSV + ' ' + 'digest'
            sig = self.hmac(message, self.secret, hashlib.sha256, 'base64')
            # eslint-disable-next-line quotes
            authorizationHeader = "hmac username=\"" + self.apiKey + "\",algorithm=\"hmac-sha256\",headers=\"" + headersCSV + "\",signature=\"" + sig + "\""
            httpHeaders = {
                'Date': date,
                'Authorization': authorizationHeader,
                'Content-Type': 'application/json',
            }
            if hasBody:
                httpHeaders = self.extend(httpHeaders, {'Digest': digest})
        return {'url': url, 'method': method, 'body': body, 'headers': httpHeaders}

    def parse_market(self, raw):
        baseId = self.safe_string(raw, 'base')
        quoteId = self.safe_string(raw, 'quote')
        base = self.safe_currency_code(baseId)
        quote = self.safe_currency_code(quoteId)
        symbol = base + '/' + quote
        state = self.safe_string(raw, 'state')
        active = state.upper() == 'TRADING'
        rules = self.safe_value(raw, 'tradingRules')
        qtyMin = None
        qtyMax = None
        costMin = None
        costMax = None
        rule = None
        if rules:
            for i in range(0, len(rules)):
                rule = rules[i]
                attribute = self.safe_value(rule, 'attribute')
                condition = self.safe_value(rule, 'condition')
                value = self.safe_value(rule, 'value')
                if (attribute == 'Qty') and (condition == 'Min'):
                    qtyMin = value
                elif (attribute == 'Qty') and (condition == 'Max'):
                    qtyMax = value
                elif (attribute == 'Cost') and (condition == 'Min'):
                    costMin = value
                elif (attribute == 'Cost') and (condition == 'Max'):
                    costMax = value
        result = {
            'id': self.safe_string(raw, 'id'),
            'baseId': baseId,
            'quoteId': quoteId,
            'base': base,
            'quote': quote,
            'symbol': symbol,
            'active': active,
            'limits': {
                'amount': {
                    'min': qtyMin,
                    'max': qtyMax,
                },
                'price': {
                    'min': None,
                    'max': None,
                },
                'cost': {
                    'min': costMin,
                    'max': costMax,
                },
            },
            'precision': {
                'price': 8,
                'amount': 8,
                'cost': 8,
            },
            'info': raw,
        }
        return result

    def fetch_markets(self, params={}):
        markets = self.publicGetMarkets(params)
        result = []
        if markets:
            for i in range(0, len(markets)):
                market = self.parse_market(markets[i])
                result.append(market)
        return result

    def parse_ticker(self, raw):
        id = self.safe_integer(raw, 'marketId')
        market = self.find_market(id)
        timestamp = self.safe_integer(raw, 'time')
        price = self.safe_float(raw, 'price')
        result = {
            'symbol': market['symbol'],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'last': price,
            'high': self.safe_float(raw, 'high'),
            'low': self.safe_float(raw, 'low'),
            'change': self.safe_float(raw, 'change'),
            'baseVolume': self.safe_float(raw, 'volumeBase'),
            'quoteVolume': self.safe_float(raw, 'volume'),
            'ask': None,
            'askVolume': None,
            'average': None,
            'bid': None,
            'bidVolume': None,
            'close': price,
            'open': None,
            'percentage': None,
            'previousClose': None,
            'vwap': None,
            'info': raw,
        }
        return result

    def fetch_ticker(self, symbol, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchTicker requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        rawTickers = self.publicGetTickers(params)
        raw = None
        if rawTickers:
            for i in range(0, len(rawTickers)):
                if self.safe_string(rawTickers[i], 'marketId') == market['id']:
                    raw = rawTickers[i]
                    break
        result = self.parse_ticker(raw)
        return result

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        rawTickers = self.publicGetTickers(params)
        result = []
        if rawTickers:
            for i in range(0, len(rawTickers)):
                result.append(self.parse_ticker(rawTickers[i]))
        return self.filter_by_array(result, 'symbol', symbols)

    def parse_trade(self, raw, market):
        price = self.safe_float(raw, 'price')
        qty = self.safe_float(raw, 'qty')
        fee = self.safe_float(raw, 'fee')
        feeAsset = self.safe_string(raw, 'feeAsset')
        cost = self.safe_float(raw, 'qty')
        if not cost:
            cost = int(round(price * qty, market.precision.cost))
        timestamp = self.safe_integer(raw, 'executedAt')
        if not timestamp:
            timestamp = self.safe_integer(raw, 'filledAt')
        rawSide = self.safe_string(raw, 'side')
        side = rawSide == 'buy' if '1' else 'sell'
        rawLiquidity = self.safe_string(raw, 'liquidity')
        liquidity = rawLiquidity == 'maker' if '1' else 'taker'
        orderId = self.safe_string(raw, 'orderId')
        return {
            'symbol': market['symbol'],
            'id': self.safe_string(raw, 'id'),
            'side': side,
            'price': price,
            'amount': qty,
            'cost': cost,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'takerOrMaker': liquidity,
            'order': orderId,
            'type': None,
            'fee': {
                'cost': fee,
                'currency': self.safe_currency_code(feeAsset),
            },
            'info': raw,
        }

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'id': market['id'],
        }
        response = self.publicGetMarketsIdTrades(self.extend(request, params))
        return self.parse_trades(response, market)

    def fetch_balance(self, params={}):
        self.load_markets()
        request = {
            'id': self.uid,
        }
        rawBalances = self.privateGetAccountsIdBalances(self.extend(request, params))
        result = {'info': rawBalances}
        if rawBalances:
            for i in range(0, len(rawBalances)):
                rawBalance = rawBalances[i]
                assetId = self.safe_string(rawBalance, 'assetId')
                assetCode = self.safe_currency_code(assetId)
                account = {
                    'free': self.safe_float(rawBalance, 'available'),
                    'used': self.safe_float(rawBalance, 'reserved'),
                    'total': self.safe_float(rawBalance, 'balance'),
                }
                result[assetCode] = account
        return self.parse_balance(result)

    def parse_order(self, raw, market=None):
        if market is None:
            marketId = self.safe_integer(raw, 'marketId')
            market = self.find_market(marketId)
        id = self.safe_string(raw, 'id')
        timestamp = self.safe_integer(raw, 'placedAt')
        rawSide = self.safe_string(raw, 'side')
        side = rawSide == 'buy' if '1' else 'sell'
        rawType = self.safe_string(raw, 'type')
        type = None
        if rawType == '1':
            type = 'market'
        elif rawType == '2':
            type = 'limit'
        elif rawType == '3':
            type = 'market'
        else:
            type = 'limit'
        price = self.safe_float(raw, 'limitPrice')
        amount = self.safe_float(raw, 'qty')
        remaining = self.safe_float(raw, 'remainingQty')
        filled = amount - remaining
        if filled > 0:
            filled = int(round(filled, market.precision.qty))
        cost = int(round(price * filled, market.precision.cost))
        rawState = self.safe_string(raw, 'state')
        state = rawState.upper() == 'closed' if '4' else 'open'
        if type == 'market':
            if price == 0.0:
                if (cost is not None) and (filled is not None):
                    if (cost > 0) and (filled > 0):
                        price = cost / filled
        fee = None
        average = None
        if cost is not None:
            if filled:
                average = int(round(cost / filled, market.precision.qty))
        return {
            'info': raw,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': market.symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'average': average,
            'filled': filled,
            'remaining': remaining,
            'status': state,
            'fee': fee,
            'trades': None,
        }

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrders requires a symbol argument')
        if self.safe_string(params, 'state') is None:
            raise ArgumentsRequired(self.id + ' fetchOrders requires a state argument')
        self.load_markets()
        market = self.market(symbol)
        yesterdayTimestamp = self.now() - 86400
        request = {
            'id': self.uid,
            'marketId': market['id'],
            'state': 'ACTIVE',
            'from': yesterdayTimestamp,
            'limit': 10,
            'offset': 0,
        }
        if since is not None:
            request['from'] = since
        if limit is not None:
            request['limit'] = limit
        response = self.privateGetAccountsIdOrders(self.extend(request, params))
        return self.parse_orders(response, market, since, limit)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchClosedOrders requires a symbol argument')
        orders = self.fetch_orders(symbol, since, limit, self.extend({'state': 'INACTIVE'}, params))
        return orders

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOpenOrders requires a symbol argument')
        orders = self.fetch_orders(symbol, since, limit, self.extend({'state': 'ACTIVE'}, params))
        return orders

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchMyTrades requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        yesterdayTimestamp = self.now() - 86400
        request = {
            'id': self.uid,
            'marketId': market['id'],
            'from': yesterdayTimestamp,
            'limit': 10,
            'offset': 0,
        }
        if since is not None:
            request['from'] = since
        if limit is not None:
            request['limit'] = limit
        response = self.privateGetAccountsIdFills(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        uppercaseType = type.upper()
        type = None
        if uppercaseType == 'MARKET':
            type = 1
        elif uppercaseType == 'LIMIT':
            type = 2
        elif uppercaseType == 'STOPMARKET':
            type = 3
        else:
            type = 4
        uppercaseSide = side.upper()
        side = uppercaseSide == 1 if 'BUY' else 2
        request = {
            'accountId': self.uid,
            'marketId': market['id'],
            'type': type,
            'side': side,
        }
        if (uppercaseType == 'MARKET') and (uppercaseSide == 'BUY'):
            # for market buy it requires the amount of quote currency to spend
            if self.options['createMarketBuyOrderRequiresPrice']:
                if price is None:
                    raise InvalidOrder(self.id + " createOrder() requires the price argument with market buy orders to calculate total order cost(amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = False to supply the cost in the amount argument(the exchange-specific behaviour)")
                else:
                    amount = amount * price
            request['cost'] = self.amount_to_precision(symbol, amount)
        else:
            request['qty'] = self.amount_to_precision(symbol, amount)
        if uppercaseType == 'LIMIT':
            request['limitPrice'] = self.price_to_precision(symbol, price)
        request['postOnly'] = False
        request['timeInForce'] = 'GTC'
        response = self.privatePostOrders(self.extend(request, params))
        return {
            'id': self.safe_string(response, 'id'),
            'info': response,
        }

    def cancel_order(self, id, symbol=None, params={}):
        request = {
            'id': id,
        }
        self.privateDeleteOrdersId(self.extend(request, params))

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        response = []
        return self.parse_order_book(response, self.safe_integer(response, 'timestamp'))

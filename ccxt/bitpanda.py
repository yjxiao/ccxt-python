# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable


class bitpanda(Exchange):

    def describe(self):
        return self.deep_extend(super(bitpanda, self).describe(), {
            'id': 'bitpanda',
            'name': 'Bitpanda',
            'countries': ['AT'],  # Austria
            'rateLimit': 300,
            'version': 'v1',
            # new metainfo interface
            'has': {
                'createDepositAddress': True,
                'fetchBalance': True,
                'fetchCurrencies': True,
                'fetchDepositAddress': True,
                'fetchMarkets': True,
                'fetchOHLCV': True,
                'fetchOrderBook': True,
                'fetchTime': True,
                'fetchTrades': True,
                'fetchTradingFees': True,
                'fetchTicker': True,
                'fetchTickers': True,
            },
            'timeframes': {
                '1m': '1/MINUTES',
                '5m': '5/MINUTES',
                '15m': '15/MINUTES',
                '30m': '30/MINUTES',
                '1h': '1/HOURS',
                '4h': '4/HOURS',
                '1d': '1/DAYS',
                '1w': '1/WEEKS',
                '1M': '1/MONTHS',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/51840849/87309947-ec787300-c525-11ea-92c1-ae23715762b1.jpg',
                'api': {
                    'public': 'https://api.exchange.bitpanda.com/public',
                    'private': 'https://api.exchange.bitpanda.com/public',
                },
                'www': 'https://www.bitpanda.com',
                'doc': [
                    'https://developers.bitpanda.com',
                ],
                'fees': 'https://www.bitpanda.com/en/pro/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'currencies',
                        'candlesticks/{instrument_code}',
                        'fees',
                        'instruments',
                        'order-book/{instrument_code}',
                        'market-ticker',
                        'market-ticker/{instrument_code}',
                        'price-ticks/{instrument_code}',
                        'time',
                    ],
                },
                'private': {
                    'get': [
                        'account/balances',
                        'account/deposit/crypto/{currency_code}',
                        'account/deposit/fiat/EUR',
                        'account/deposits',
                        'account/deposits/bitpanda',
                        'account/withdrawals',
                        'account/withdrawals/bitpanda',
                        'account/fees',
                        'account/orders',
                        'account/orders/{order_id}',
                        'account/orders/{order_id}/trades',
                        'account/trades',
                        'account/trades/{trade_id}',
                        'account/trading-volume',
                    ],
                    'post': [
                        'account/deposit/crypto',
                        'account/withdraw/crypto',
                        'account/withdraw/fiat',
                        'account/fees',
                        'account/orders',
                    ],
                    'delete': [
                        'account/orders',
                        'account/orders/{order_id}',
                        'account/orders/client/{client_id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'taker': 0.15 / 100,
                    'maker': 0.10 / 100,
                    'tiers': [
                        # volume in BTC
                        {
                            'taker': [
                                [0, 0.15 / 100],
                                [100, 0.13 / 100],
                                [250, 0.13 / 100],
                                [1000, 0.1 / 100],
                                [5000, 0.09 / 100],
                                [10000, 0.075 / 100],
                                [20000, 0.065 / 100],
                            ],
                            'maker': [
                                [0, 0.1 / 100],
                                [100, 0.1 / 100],
                                [250, 0.09 / 100],
                                [1000, 0.075 / 100],
                                [5000, 0.06 / 100],
                                [10000, 0.05 / 100],
                                [20000, 0.05 / 100],
                            ],
                        },
                    ],
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': False,
            },
            # exchange-specific options
            'options': {
            },
            'exceptions': {
                'exact': {
                    'ONLY_ONE_ERC20_ADDRESS_ALLOWED': InvalidAddress,
                    'DEPOSIT_ADDRESS_NOT_USED': InvalidAddress,
                    'INVALID_CREDENTIALS': AuthenticationError,
                    'MISSING_CREDENTIALS': AuthenticationError,
                    'INVALID_APIKEY': AuthenticationError,
                    'INVALID_SCOPES': AuthenticationError,
                    'INVALID_SUBJECT': AuthenticationError,
                    'INVALID_ISSUER': AuthenticationError,
                    'INVALID_AUDIENCE': AuthenticationError,
                    'INVALID_DEVICE_ID': AuthenticationError,
                    'INVALID_IP_RESTRICTION': AuthenticationError,
                    'APIKEY_REVOKED': AuthenticationError,
                    'APIKEY_EXPIRED': AuthenticationError,
                    'SYNCHRONIZER_TOKEN_MISMATCH': AuthenticationError,
                    'SESSION_EXPIRED': AuthenticationError,
                    'INTERNAL_ERROR': AuthenticationError,
                    'CLIENT_IP_BLOCKED': PermissionDenied,
                    'MISSING_PERMISSION': PermissionDenied,
                    'ILLEGAL_CHARS': BadRequest,
                    'UNSUPPORTED_MEDIA_TYPE': BadRequest,
                    'ACCOUNT_HISTORY_TIME_RANGE_TOO_BIG': BadRequest,
                    'CANDLESTICKS_TIME_RANGE_TOO_BIG': BadRequest,
                    'INVALID_INSTRUMENT_CODE': BadRequest,
                    'INVALID_ORDER_TYPE': BadRequest,
                    'INVALID_UNIT': BadRequest,
                    'INVALID_PERIOD': BadRequest,
                    'INVALID_TIME': BadRequest,
                    'INVALID_DATE': BadRequest,
                    'INVALID_CURRENCY': BadRequest,
                    'INVALID_AMOUNT': BadRequest,
                    'INVALID_PRICE': BadRequest,
                    'INVALID_LIMIT': BadRequest,
                    'INVALID_QUERY': BadRequest,
                    'INVALID_CURSOR': BadRequest,
                    'INVALID_ACCOUNT_ID': BadRequest,
                    'INVALID_SIDE': BadRequest,
                    'INVALID_ACCOUNT_HISTORY_FROM_TIME': BadRequest,
                    'INVALID_ACCOUNT_HISTORY_MAX_PAGE_SIZE': BadRequest,
                    'INVALID_ACCOUNT_HISTORY_TIME_PERIOD': BadRequest,
                    'INVALID_ACCOUNT_HISTORY_TO_TIME': BadRequest,
                    'INVALID_CANDLESTICKS_GRANULARITY': BadRequest,
                    'INVALID_CANDLESTICKS_UNIT': BadRequest,
                    'INVALID_ORDER_BOOK_DEPTH': BadRequest,
                    'INVALID_ORDER_BOOK_LEVEL': BadRequest,
                    'INVALID_PAGE_CURSOR': BadRequest,
                    'INVALID_TIME_RANGE': BadRequest,
                    'INVALID_TRADE_ID': BadRequest,
                    'INVALID_UI_ACCOUNT_SETTINGS': BadRequest,
                    'NEGATIVE_AMOUNT': BadRequest,
                    'NEGATIVE_PRICE': BadRequest,
                    'MIN_SIZE_NOT_SATISFIED': BadRequest,
                    'BAD_AMOUNT_PRECISION': BadRequest,
                    'BAD_PRICE_PRECISION': BadRequest,
                    'BAD_TRIGGER_PRICE_PRECISION': BadRequest,
                    'MAX_OPEN_ORDERS_EXCEEDED': BadRequest,
                    'MISSING_PRICE': ArgumentsRequired,
                    'MISSING_ORDER_TYPE': ArgumentsRequired,
                    'MISSING_SIDE': ArgumentsRequired,
                    'MISSING_CANDLESTICKS_PERIOD_PARAM': ArgumentsRequired,
                    'MISSING_CANDLESTICKS_UNIT_PARAM': ArgumentsRequired,
                    'MISSING_FROM_PARAM': ArgumentsRequired,
                    'MISSING_INSTRUMENT_CODE': ArgumentsRequired,
                    'MISSING_ORDER_ID': ArgumentsRequired,
                    'MISSING_TO_PARAM': ArgumentsRequired,
                    'MISSING_TRADE_ID': ArgumentsRequired,
                    'INVALID_ORDER_ID': OrderNotFound,
                    'NOT_FOUND': OrderNotFound,
                    'INSUFFICIENT_LIQUIDITY': InsufficientFunds,
                    'INSUFFICIENT_FUNDS': InsufficientFunds,
                    'NO_TRADING': ExchangeNotAvailable,
                    'SERVICE_UNAVAILABLE': ExchangeNotAvailable,
                    'GATEWAY_TIMEOUT': ExchangeNotAvailable,
                    'RATELIMIT': DDoSProtection,
                    'CF_RATELIMIT': DDoSProtection,
                    'INTERNAL_SERVER_ERROR': ExchangeError,
                },
                'broad': {
                },
            },
        })

    def fetch_time(self, params={}):
        response = self.publicGetTime(params)
        #
        #     {
        #         iso: '2020-07-10T05:17:26.716Z',
        #         epoch_millis: 1594358246716,
        #     }
        #
        return self.safe_integer(response, 'epoch_millis')

    def fetch_currencies(self, params={}):
        response = self.publicGetCurrencies(params)
        #
        #     [
        #         {
        #             "code":"BEST",
        #             "precision":8
        #         }
        #     ]
        #
        result = {}
        for i in range(0, len(response)):
            currency = response[i]
            id = self.safe_string(currency, 'code')
            code = self.safe_currency_code(id)
            result[code] = {
                'id': id,
                'code': code,
                'name': None,
                'info': currency,  # the original payload
                'active': None,
                'fee': None,
                'precision': self.safe_integer(currency, 'precision'),
                'limits': {
                    'amount': {'min': None, 'max': None},
                    'price': {'min': None, 'max': None},
                    'cost': {'min': None, 'max': None},
                    'withdraw': {'min': None, 'max': None},
                },
            }
        return result

    def fetch_markets(self, params={}):
        response = self.publicGetInstruments(params)
        #
        #     [
        #         {
        #             state: 'ACTIVE',
        #             base: {code: 'ETH', precision: 8},
        #             quote: {code: 'CHF', precision: 2},
        #             amount_precision: 4,
        #             market_precision: 2,
        #             min_size: '10.0'
        #         }
        #     ]
        #
        result = []
        for i in range(0, len(response)):
            market = response[i]
            baseAsset = self.safe_value(market, 'base', {})
            quoteAsset = self.safe_value(market, 'quote', {})
            baseId = self.safe_string(baseAsset, 'code')
            quoteId = self.safe_string(quoteAsset, 'code')
            id = baseId + '_' + quoteId
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            precision = {
                'amount': self.safe_integer(market, 'amount_precision'),
                'price': self.safe_integer(market, 'market_precision'),
            }
            limits = {
                'amount': {
                    'min': None,
                    'max': None,
                },
                'price': {
                    'min': None,
                    'max': None,
                },
                'cost': {
                    'min': self.safe_float(market, 'min_size'),
                    'max': None,
                },
            }
            state = self.safe_string(market, 'state')
            active = (state == 'ACTIVE')
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'precision': precision,
                'limits': limits,
                'info': market,
                'active': active,
            })
        return result

    def fetch_trading_fees(self, params={}):
        self.load_markets()
        response = self.publicGetFees(params)
        #
        #     [
        #         {
        #             "fee_group_id":"default",
        #             "display_text":"The standard fee plan.",
        #             "fee_tiers":[
        #                 {"volume":"0.0","fee_group_id":"default","maker_fee":"0.1","taker_fee":"0.15"},
        #                 {"volume":"100.0","fee_group_id":"default","maker_fee":"0.1","taker_fee":"0.13"},
        #                 {"volume":"250.0","fee_group_id":"default","maker_fee":"0.09","taker_fee":"0.13"},
        #                 {"volume":"1000.0","fee_group_id":"default","maker_fee":"0.075","taker_fee":"0.1"},
        #                 {"volume":"5000.0","fee_group_id":"default","maker_fee":"0.06","taker_fee":"0.09"},
        #                 {"volume":"10000.0","fee_group_id":"default","maker_fee":"0.05","taker_fee":"0.075"},
        #                 {"volume":"20000.0","fee_group_id":"default","maker_fee":"0.05","taker_fee":"0.065"}
        #             ],
        #             "fee_discount_rate":"25.0",
        #             "minimum_price_value":"0.12"
        #         }
        #     ]
        #
        feeGroupsById = self.index_by(response, 'fee_group_id')
        feeGroupId = self.safe_value(self.options, 'fee_group_id', 'default')
        feeGroup = self.safe_value(feeGroupsById, feeGroupId, {})
        feeTiers = self.safe_value(feeGroup, 'fee_tiers')
        result = {}
        for i in range(0, len(self.symbols)):
            symbol = self.symbols[i]
            fee = {
                'info': feeGroup,
                'symbol': symbol,
                'maker': None,
                'taker': None,
                'percentage': True,
                'tierBased': True,
            }
            takerFees = []
            makerFees = []
            for i in range(0, len(feeTiers)):
                tier = feeTiers[i]
                volume = self.safe_float(tier, 'volume')
                taker = self.safe_float(tier, 'taker_fee')
                maker = self.safe_float(tier, 'maker_fee')
                taker /= 100
                maker /= 100
                takerFees.append([volume, taker])
                makerFees.append([volume, maker])
                if i == 0:
                    fee['taker'] = taker
                    fee['maker'] = maker
            tiers = {
                'taker': takerFees,
                'maker': makerFees,
            }
            fee['tiers'] = tiers
            result[symbol] = fee
        return result

    def parse_ticker(self, ticker, market=None):
        #
        # fetchTicker, fetchTickers
        #
        #     {
        #         "instrument_code":"BTC_EUR",
        #         "sequence":602562,
        #         "time":"2020-07-10T06:27:34.951Z",
        #         "state":"ACTIVE",
        #         "is_frozen":0,
        #         "quote_volume":"1695555.1783768",
        #         "base_volume":"205.67436",
        #         "last_price":"8143.91",
        #         "best_bid":"8143.71",
        #         "best_ask":"8156.9",
        #         "price_change":"-147.47",
        #         "price_change_percentage":"-1.78",
        #         "high":"8337.45",
        #         "low":"8110.0"
        #     }
        #
        timestamp = self.parse8601(self.safe_string(ticker, 'time'))
        marketId = self.safe_string(ticker, 'instrument_code')
        symbol = None
        if marketId is not None:
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
            elif marketId is not None:
                baseId, quoteId = marketId.split('_')
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
        if (symbol is None) and (market is not None):
            symbol = market['symbol']
        last = self.safe_float(ticker, 'last_price')
        percentage = self.safe_float(ticker, 'price_change_percentage')
        change = self.safe_float(ticker, 'price_change')
        open = None
        average = None
        if (last is not None) and (change is not None):
            open = last - change
            average = self.sum(last, open) / 2
        baseVolume = self.safe_float(ticker, 'base_volume')
        quoteVolume = self.safe_float(ticker, 'quote_volume')
        vwap = None
        if quoteVolume is not None and baseVolume is not None:
            vwap = quoteVolume / baseVolume
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': self.safe_float(ticker, 'best_bid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'best_ask'),
            'askVolume': None,
            'vwap': vwap,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': change,
            'percentage': percentage,
            'average': average,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'instrument_code': market['id'],
        }
        response = self.publicGetMarketTickerInstrumentCode(self.extend(request, params))
        #
        #     {
        #         "instrument_code":"BTC_EUR",
        #         "sequence":602562,
        #         "time":"2020-07-10T06:27:34.951Z",
        #         "state":"ACTIVE",
        #         "is_frozen":0,
        #         "quote_volume":"1695555.1783768",
        #         "base_volume":"205.67436",
        #         "last_price":"8143.91",
        #         "best_bid":"8143.71",
        #         "best_ask":"8156.9",
        #         "price_change":"-147.47",
        #         "price_change_percentage":"-1.78",
        #         "high":"8337.45",
        #         "low":"8110.0"
        #     }
        #
        return self.parse_ticker(response, market)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        tickers = self.publicGetMarketTicker(params)
        #
        #     [
        #         {
        #             "instrument_code":"BTC_EUR",
        #             "sequence":602562,
        #             "time":"2020-07-10T06:27:34.951Z",
        #             "state":"ACTIVE",
        #             "is_frozen":0,
        #             "quote_volume":"1695555.1783768",
        #             "base_volume":"205.67436",
        #             "last_price":"8143.91",
        #             "best_bid":"8143.71",
        #             "best_ask":"8156.9",
        #             "price_change":"-147.47",
        #             "price_change_percentage":"-1.78",
        #             "high":"8337.45",
        #             "low":"8110.0"
        #         }
        #     ]
        #
        result = {}
        for i in range(0, len(tickers)):
            ticker = self.parse_ticker(tickers[i])
            symbol = ticker['symbol']
            result[symbol] = ticker
        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        request = {
            'instrument_code': self.market_id(symbol),
            # level 1 means only the best bid and ask
            # level 2 is a compiled order book up to market precision
            # level 3 is a full orderbook
            # if you wish to get regular updates about orderbooks please use the Websocket channel
            # heavy usage of self endpoint may result in limited access according to rate limits rules
            # 'level': 3,  # default
        }
        if limit is not None:
            request['depth'] = limit
        response = self.publicGetOrderBookInstrumentCode(self.extend(request, params))
        #
        # level 1
        #
        #     {
        #         "instrument_code":"BTC_EUR",
        #         "time":"2020-07-10T07:39:06.343Z",
        #         "asks":{
        #             "value":{
        #                 "price":"8145.29",
        #                 "amount":"0.96538",
        #                 "number_of_orders":1
        #             }
        #         },
        #         "bids":{
        #             "value":{
        #                 "price":"8134.0",
        #                 "amount":"1.5978",
        #                 "number_of_orders":5
        #             }
        #         }
        #     }
        #
        # level 2
        #
        #     {
        #         "instrument_code":"BTC_EUR","time":"2020-07-10T07:36:43.538Z",
        #         "asks":[
        #             {"price":"8146.59","amount":"0.89691","number_of_orders":1},
        #             {"price":"8146.89","amount":"1.92062","number_of_orders":1},
        #             {"price":"8169.5","amount":"0.0663","number_of_orders":1},
        #         ],
        #         "bids":[
        #             {"price":"8143.49","amount":"0.01329","number_of_orders":1},
        #             {"price":"8137.01","amount":"5.34748","number_of_orders":1},
        #             {"price":"8137.0","amount":"2.0","number_of_orders":1},
        #         ]
        #     }
        #
        # level 3
        #
        #     {
        #         "instrument_code":"BTC_EUR",
        #         "time":"2020-07-10T07:32:31.525Z",
        #         "bids":[
        #             {"price":"8146.79","amount":"0.01537","order_id":"5d717da1-a8f4-422d-afcc-03cb6ab66825"},
        #             {"price":"8139.32","amount":"3.66009","order_id":"d0715c68-f28d-4cf1-a450-d56cf650e11c"},
        #             {"price":"8137.51","amount":"2.61049","order_id":"085fd6f4-e835-4ca5-9449-a8f165772e60"},
        #         ],
        #         "asks":[
        #             {"price":"8153.49","amount":"0.93384","order_id":"755d3aa3-42b5-46fa-903d-98f42e9ae6c4"},
        #             {"price":"8153.79","amount":"1.80456","order_id":"62034cf3-b70d-45ff-b285-ba6307941e7c"},
        #             {"price":"8167.9","amount":"0.0018","order_id":"036354e0-71cd-492f-94f2-01f7d4b66422"},
        #         ]
        #     }
        #
        timestamp = self.parse8601(self.safe_string(response, 'time'))
        return self.parse_order_book(response, timestamp, 'bids', 'asks', 'price', 'amount')

    def parse_ohlcv(self, ohlcv, market=None):
        #
        #     {
        #         "instrument_code":"BTC_EUR",
        #         "granularity":{"unit":"HOURS","period":1},
        #         "high":"9252.65",
        #         "low":"9115.27",
        #         "open":"9250.0",
        #         "close":"9132.35",
        #         "total_amount":"33.85924",
        #         "volume":"311958.9635744",
        #         "time":"2020-05-08T22:59:59.999Z",
        #         "last_sequence":461123
        #     }
        #
        granularity = self.safe_value(ohlcv, 'granularity')
        unit = self.safe_string(granularity, 'unit')
        period = self.safe_string(granularity, 'period')
        units = {
            'MINUTES': 'm',
            'HOURS': 'h',
            'DAYS': 'd',
            'WEEKS': 'w',
            'MONTHS': 'M',
        }
        lowercaseUnit = self.safe_string(units, unit)
        timeframe = period + lowercaseUnit
        durationInSeconds = self.parse_timeframe(timeframe)
        duration = durationInSeconds * 1000
        timestamp = self.parse8601(self.safe_string(ohlcv, 'time'))
        modulo = self.integer_modulo(timestamp, duration)
        alignedTimestamp = timestamp - modulo
        options = self.safe_value(self.options, 'fetchOHLCV', {})
        volumeField = self.safe_string(options, 'volume', 'total_amount')
        return [
            alignedTimestamp,
            self.safe_float(ohlcv, 'open'),
            self.safe_float(ohlcv, 'high'),
            self.safe_float(ohlcv, 'low'),
            self.safe_float(ohlcv, 'close'),
            self.safe_float(ohlcv, volumeField),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        periodUnit = self.safe_string(self.timeframes, timeframe)
        period, unit = periodUnit.split('/')
        durationInSeconds = self.parse_timeframe(timeframe)
        duration = durationInSeconds * 1000
        if limit is None:
            limit = 1500
        request = {
            'instrument_code': market['id'],
            # 'from': self.iso8601(since),
            # 'to': self.iso8601(self.milliseconds()),
            'period': period,
            'unit': unit,
        }
        if since is None:
            now = self.milliseconds()
            request['to'] = self.iso8601(now)
            request['from'] = self.iso8601(now - limit * duration)
        else:
            request['from'] = self.iso8601(since)
            request['to'] = self.iso8601(self.sum(since, limit * duration))
        response = self.publicGetCandlesticksInstrumentCode(self.extend(request, params))
        #
        #     [
        #         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9252.65","low":"9115.27","open":"9250.0","close":"9132.35","total_amount":"33.85924","volume":"311958.9635744","time":"2020-05-08T22:59:59.999Z","last_sequence":461123},
        #         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9162.49","low":"9040.0","open":"9132.53","close":"9083.69","total_amount":"26.19685","volume":"238553.7812365","time":"2020-05-08T23:59:59.999Z","last_sequence":461376},
        #         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9135.7","low":"9002.59","open":"9055.45","close":"9133.98","total_amount":"26.21919","volume":"238278.8724959","time":"2020-05-09T00:59:59.999Z","last_sequence":461521},
        #     ]
        #
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades(public)
        #
        #     {
        #         "instrument_code":"BTC_EUR",
        #         "price":"8137.28",
        #         "amount":"0.22269",
        #         "taker_side":"BUY",
        #         "volume":"1812.0908832",
        #         "time":"2020-07-10T14:44:32.299Z",
        #         "trade_timestamp":1594392272299,
        #         "sequence":603047
        #     }
        #
        timestamp = self.parse8601(self.safe_string(trade, 'time'))
        side = self.safe_string_lower(trade, 'taker_side')
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'amount')
        cost = self.safe_float(trade, 'volume')
        marketId = self.safe_string(trade, 'instrument_code')
        symbol = None
        if marketId is not None:
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
                symbol = market['symbol']
            else:
                baseId, quoteId = marketId.split('_')
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
        if (market is not None) and (symbol is None):
            symbol = market['symbol']
        return {
            'id': self.safe_string(trade, 'sequence'),
            'order': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': None,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'takerOrMaker': None,
            'fee': None,
            'info': trade,
        }

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'instrument_code': market['id'],
            # 'from': self.iso8601(since),
            # 'to': self.iso8601(self.milliseconds()),
        }
        if since is not None:
            # returns price ticks for a specific market with an interval of maximum of 4 hours
            # sorted by latest first
            request['from'] = self.iso8601(since)
            request['to'] = self.iso8601(self.sum(since, 14400000))
        response = self.publicGetPriceTicksInstrumentCode(self.extend(request, params))
        #
        #     [
        #         {
        #             "instrument_code":"BTC_EUR",
        #             "price":"8137.28",
        #             "amount":"0.22269",
        #             "taker_side":"BUY",
        #             "volume":"1812.0908832",
        #             "time":"2020-07-10T14:44:32.299Z",
        #             "trade_timestamp":1594392272299,
        #             "sequence":603047
        #         }
        #     ]
        #
        return self.parse_trades(response, market, since, limit)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api] + '/' + self.version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        elif api == 'private':
            self.check_required_credentials()
            headers = {
                'Accept': 'application/json',
                'Authorization': 'Bearer ' + self.apiKey,
            }
            if method == 'POST':
                body = self.json(query)
                headers['Content-Type'] = 'application/json'
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetAccountBalances(params)
        #
        #     {
        #         "account_id":"4b95934f-55f1-460c-a525-bd5afc0cf071",
        #         "balances":[
        #             {
        #                 "account_id":"4b95934f-55f1-460c-a525-bd5afc0cf071",
        #                 "currency_code":"BTC",
        #                 "change":"10.0",
        #                 "available":"10.0",
        #                 "locked":"0.0",
        #                 "sequence":142135994,
        #                 "time":"2020-07-01T10:57:32.959Z"
        #             }
        #         ]
        #     }
        #
        balances = self.safe_value(response, 'balances', [])
        result = {'info': response}
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'currency_code')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_float(balance, 'available')
            account['used'] = self.safe_float(balance, 'locked')
            result[code] = account
        return self.parse_balance(result)

    def parse_deposit_address(self, depositAddress, currency=None):
        code = None
        if currency is not None:
            code = currency['code']
        address = self.safe_string(depositAddress, 'address')
        tag = self.safe_string(depositAddress, 'destination_tag')
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': depositAddress,
        }

    def create_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privatePostAccountDepositCrypto(self.extend(request, params))
        #
        #     {
        #         "address":"rBnNhk95FrdNisZtXcStzriFS8vEzz53DM",
        #         "destination_tag":"865690307",
        #         "enabled":true,
        #         "is_smart_contract":false
        #     }
        #
        return self.parse_deposit_address(response, currency)

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency_code': currency['id'],
        }
        response = self.privateGetAccountDepositCryptoCurrencyCode(self.extend(request, params))
        #
        #     {
        #         "address":"rBnNhk95FrdNisZtXcStzriFS8vEzz53DM",
        #         "destination_tag":"865690307",
        #         "enabled":true,
        #         "is_smart_contract":false,
        #         "can_create_more":false
        #     }
        #
        return self.parse_deposit_address(response, currency)

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return
        #
        #     {"error":"MISSING_FROM_PARAM"}
        #     {"error":"MISSING_TO_PARAM"}
        #     {"error":"CANDLESTICKS_TIME_RANGE_TOO_BIG"}
        #
        feedback = self.id + ' ' + body
        message = self.safe_string(response, 'error')
        if message is not None:
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
            raise ExchangeError(feedback)  # unknown message

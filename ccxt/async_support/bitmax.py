# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import hashlib
import math
import time
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder, NotSupported
from ccxt.base.decimal_to_precision import ROUND

CASH = 'cash'
MARGIN = 'margin'
FUTURES = 'futures'

ALL_ACCOUNTS = [CASH, MARGIN, FUTURES]


class bitmax(Exchange):
    """
    There are cash/margin/futures accounts for each bitmax user.
    You could provide it when call the api: params = {'account': 'cash'/'margin'/'futures'};
    or you can set in advance by calling set_account(account), where account is one of 'cash'/'margin'/'futures'.
    e.g.  bitmax.create_order('BTC-PERP', 'limit', 'buy', 0.01, 7125, params = {'account':'futures'})
    or bitmax.set_account('futures')
    """
    def describe(self):
        return self.deep_extend(super(bitmax, self).describe(), {
            'id': 'bitmax',
            'name': 'BitMax',
            'countries': ['CN'],  # China
            'rateLimit': 500,
            'certified': False,
            # new metainfo interface
            'has': {
                'CORS': False,
                'fetchAccounts': True,
                'fetchTickers': True,
                'fetchOHLCV': True,
                'fetchMyTrades': False,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOpenOrders': True,
                'fetchOrderTrades': False,
                'fetchClosedOrders': True,
                'fetchTransactions': False,
                'fetchCurrencies': True,
                'cancelAllOrders': False,
                'fetchDepositAddress': True,
            },
            'timeframes': {
                '1m': '1',
                '3m': '3',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '6h': '360',
                '12h': '720',
                '1d': '1d',
                '1w': '1w',
                '1M': '1m',
            },
            'version': 'v1',
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/66820319-19710880-ef49-11e9-8fbe-16be62a11992.jpg',
                'api': 'https://bitmax.io',
                'test': 'https://bitmax-test.io/api',
                'www': 'https://bitmax.io',
                'doc': [
                    'https://bitmax-exchange.github.io/bitmax-pro-api/#rest-apis',
                ],
                'fees': 'https://bitmax.io/#/feeRate/tradeRate',
                'referral': 'https://bitmax.io/#/register?inviteCode=T6J9R0EB',
            },
            'api': {
                'public': {
                    'get': [
                        'assets',
                        'barhist',
                        'barhist/info',
                        'cash/assets',
                        'cash/products',
                        'depth',
                        'fees',
                        'futures/collateral',
                        'futures/contracts',
                        'depth',
                        'margin/assets',
                        'margin/products',
                        'margin/ref-price',
                        'trades',
                        'products',
                        'ticker'
                    ],
                },
                'private': {
                    'get': [
                        'cash/balance',
                        'cash/order/hist/current',
                        'cash/order/open',
                        'cash/order/status',
                        'futures/balance',
                        'futures/order/hist/current',
                        'futures/order/open',
                        'futures/order/status',
                        'margin/balance',
                        'margin/order/hist/current',
                        'margin/order/open',
                        'margin/order/status',
                        'margin/risk',
                        'order/hist',
                        'transaction',
                        'info',
                        'wallet/deposit/address',
                    ],
                    'post': [
                        'cash/order',
                        'cash/order/batch',
                        'futures/order',
                        'futures/order/batch',
                        'margin/order',
                        'margin/order/batch',
                    ],
                    'delete': [
                        'cash/order',
                        'cash/order/all',
                        'cash/order/batch',
                        'margin/order',
                        'margin/order/all',
                        'margin/order/batch',
                        'futures/order',
                        'futures/order/all',
                        'futures/order/batch'
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'percentage': True,
                    'taker': 0.001,
                    'maker': 0.001,
                },
            },
            'options': {
                'account': CASH,
                'accountGroup': None,
                'parseOrderToPrecision': False,
            },
            'exceptions': {
                'exact': {
                    # TODO: fix error code mapping
                    '2100': AuthenticationError,  # {"code":2100,"message":"ApiKeyFailure"}
                    '5002': BadSymbol,  # {"code":5002,"message":"Invalid Symbol"}
                    '6010': InsufficientFunds,  # {'code': 6010, 'message': 'Not enough balance.'}
                    '60060': InvalidOrder,  # {'code': 60060, 'message': 'The order is already filled or canceled.'}
                    '600503': InvalidOrder,  # {"code":600503,"message":"Notional is too small."}
                },
                'broad': {},
            },
        })

    def get_account(self, params={}):
        return params.setdefault('account', self.options['account']).lower().capitalize()

    def set_account(self, account):
        if account not in [CASH, MARGIN, FUTURES]:
            raise NotSupported(f"account {account}")
        self.options[account] = account

    def get_futures_collateral(self, params={}):
        response = self.publicGetFuturesCollateral(params)
        return self.safe_value(response, 'data', [])

    async def fetch_currencies(self, params={}):
        response = self.publicGetAssets(params)
        # {
        #     "code": 0,
        #     "data": [
        #         {
        #             "assetCode": "ONG",
        #             "assetName": "ONG",
        #             "precisionScale": 9,
        #             "nativeScale": 3,
        #             "withdrawalFee": "1.0",
        #             "minWithdrawalAmt": "2.0",
        #             "status": "Normal"
        #         }
        #     ]
        # }

        result = {}

        if response['code'] != 0:
            # log error
            return result

        records = response['data']

        for i in range(0, len(records)):
            currency = records[i]
            id = self.safe_string(currency, 'assetCode')
            # Todo: tiered fee make fee calculation complicated now. To provide separate fee related method.
            code = self.safe_currency_code(id)
            precision = self.safe_integer(currency, 'precisionScale')
            fee = self.safe_float(currency, 'withdrawalFee')  # todo: redesign
            status = self.safe_string(currency, 'status')
            active = (status == 'Normal')
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'type': None,
                'name': self.safe_string(currency, 'assetName'),
                'active': active,
                'fee': fee,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': math.pow(10, -precision),
                        'max': None,
                    },
                    'price': {
                        'min': math.pow(10, -precision),
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'withdraw': {
                        'min': self.safe_float(currency, 'minWithdrawalAmt'),
                        'max': None,
                    },
                },
            }
        return result

    async def fetch_markets(self, params={}):
        response = self.publicGetProducts(params)
        # {
        #     "code": 0,
        #     "data": [
        #         {
        #             "symbol": "DAD/USDT",
        #             "baseAsset": "DAD",
        #             "quoteAsset": "USDT",
        #             "status": "Normal",
        #             "minNotional": "5",
        #             "maxNotional": "50000",
        #             "marginTradable": False,
        #             "commissionType": "Quote",
        #             "commissionReserveRate": "0.001",
        #             "tickSize": "0.00001",
        #             "lotSize": "1"
        #         }
        #     ]
        # }
        result = []
        if response['code'] != 0:
            # log error
            return result

        records = response['data']

        for i in range(0, len(records)):
            market = records[i]
            id = self.safe_string(market, 'symbol')
            baseId = self.safe_string(market, 'baseAsset')
            quoteId = self.safe_string(market, 'quoteAsset')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = id  # base + '/' + quote
            precision = {
                'amount': self.precision_from_string(self.safe_string(market, 'lotSize')),
                'price': self.precision_from_string(self.safe_string(market, 'tickSize'))
            }
            status = self.safe_string(market, 'status')
            active = (status == 'Normal')
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': self.safe_float(market, 'lotSize'),
                        'max': None,
                    },
                    'price': {'min': self.safe_float(market, "tickSize"), 'max': None},
                    'cost': {
                        'min': self.safe_float(market, 'minNotional'),
                        'max': self.safe_float(market, 'maxNotional'),
                    },
                },
            })
        return result

    # TODO: fee calculation here is incorrect, we need to support tiered fee calculation.
    def calculate_fee(self, symbol, type, side, amount, price, takerOrMaker='taker', params={}):
        market = self.markets[symbol]
        key = 'quote'
        rate = market[takerOrMaker]
        cost = amount * rate
        precision = market['precision']['price']
        if side == 'sell':
            cost *= price
        else:
            key = 'base'
            precision = market['precision']['amount']
        cost = self.decimal_to_precision(cost, ROUND, precision, self.precisionMode)
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': float(cost),
        }

    def fetch_accounts(self, params={}):
        accountGroup = self.safe_string(self.options, 'accountGroup')
        records = None
        if accountGroup is None:
            response = self.privateGetInfo(params)
            # {'code': 0,
            #  'data': {'email': 'xxxcc@gmail.com',
            #           'accountGroup': 5,
            #           'viewPermission': True,
            #           'tradePermission': True,
            #           'transferPermission': True,
            #           'withdrawPermission': True,
            #           'cashAccount': ['xxxxxxxxxxxxxxxxxxxxxxxxxx'],
            #           'marginAccount': ['yyyyyyyyyyyyyyyyyyyyyyyyy'],
            #           'futuresAccount': ['zzzzzzzzzzzzzzzzzzzzzzzzz'],
            #           'userUID': 'U123456789'}
            #  }

            if response['code'] == 0:
                records = response['data']
                accountGroup = self.safe_string(records, 'accountGroup')
                self.options['accountGroup'] = accountGroup
        return [
            {
                'id': accountGroup,
                'type': None,
                'currency': None,
                'info': records,
            },
        ]

    async def fetch_balance(self, params={}):
        self.load_markets()
        self.load_accounts()

        response = getattr(self, f'privateGet{self.get_account(params)}Balance')(params)

        #
        #     {
        #         "code": 0,
        #         "status": "success",  # self field will be deprecated soon
        #         "email": "foo@bar.com",  # self field will be deprecated soon
        #         "data": [
        #             {
        #                 "assetCode": "TSC",
        #                 "assetName": "Ethereum",
        #                 "totalAmount": "20.03",  # total balance amount
        #                 "availableAmount": "20.03",  # balance amount available to trade
        #                 "inOrderAmount": "0.000",  # in order amount
        #                 "btcValue": "70.81"     # the current BTC value of the balance, may be missing
        #             },
        #         ]
        #     }
        #
        balances = self.safe_value(response, 'data', [])
        result = {'info': balances}
        for i in range(0, len(balances)):
            balance = balances[i]
            code = self.safe_currency_code(self.safe_string(balance, 'asset'))
            account = self.account()
            account['total'] = self.safe_float(balance, 'totalBalance')
            account['free'] = self.safe_float(balance, 'availableBalance')
            account['used'] = account['total'] - account['free']
            result[code] = account
        return self.parse_balance(result)

    async def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['n'] = limit  # default = maximum = 100
        response = self.publicGetDepth(self.extend(request, params))
        # {
        #     "code": 0,
        #     "data": {
        #         "m": "depth-snapshot",
        #         "symbol": "BTC/USDT",
        #         "data": {
        #             "ts": 1583558793465,
        #             "seqnum": 8273359781,
        #             "asks": [
        #                 [
        #                     "9082.73",
        #                     "1.31752"
        #                 ],
        #                 [
        #                     "9082.76",
        #                     "0.00342"
        #                 ]
        #             ],
        #             "bid": [
        #                 [
        #                     "5532.27",
        #                     "0.00606"
        #                 ],
        #                 [
        #                     "4858.54",
        #                     "0.02789"
        #                 ]
        #             ]
        #         }}}

        result = {}
        if response['code'] == 0:
            response_data = response['data']
            if len(response_data) > 0 and len(response_data['data']) > 0:
                records = response_data['data']
                timestamp = self.safe_integer(records, 'ts')
                result = self.parse_order_book(records, timestamp)
                result['nonce'] = self.safe_integer(records, 'seqnum')
        return result

    def parse_ticker(self, ticker, market=None):
        #
        # {
        #     'symbol': 'BTC/USDT',
        #     'open': '8086.63',
        #     'close': '7846.16',
        #     'high': '7846.16',
        #     'low': '7846.16',
        #     'volume': '8100.10864',
        #     'ask': ['7847.7', '0.52882'],
        #     'bid': ['7846.87', '3.9718']
        # }
        #
        timestamp = int(time.time() * 1000)
        timestamp = timestamp - timestamp % 60000
        symbol = None
        marketId = self.safe_string(ticker, 'symbol')
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
        elif marketId is not None:
            baseId, quoteId = marketId.split('/')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
        if (symbol is None) and (market is not None):
            symbol = market['symbol']
        last = self.safe_float(ticker, 'close')
        bid = self.safe_value(ticker, 'bid', [None, None])
        ask = self.safe_value(ticker, 'ask', [None, None])

        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': bid[0],
            'bidVolume': bid[1],
            'ask': ask[0],
            'askVolume': ask[1],
            'vwap': None,
            'open': self.safe_float(ticker, 'open'),
            'close': last,
            'last': last,
            'previousClose': None,  # previous day close
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, 'volume'),
            'quoteVolume': None,
            'info': ticker,
        }

    def parse_tickers(self, rawTickers, symbols=None):
        tickers = []
        for i in range(0, len(rawTickers)):
            tickers.append(self.parse_ticker(rawTickers[i]))
        return self.filter_by_array(tickers, 'symbol', symbols)

    async def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = self.publicGetTicker(self.extend(request, params))
        #
        # {
        #     'code': 0,
        #     'data':
        #         {
        #             'symbol': 'BTC/USDT',
        #             'open': '8086.63',
        #             'close': '7846.16',
        #             'high': '7846.16',
        #             'low': '7846.16',
        #             'volume': '8100.10864',
        #             'ask': ['7847.7', '0.52882'],
        #             'bid': ['7846.87', '3.9718']
        #         }
        # }
        #

        records = self.safe_value(response, 'data', {})
        return self.parse_ticker(records, market)

    async def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        response = self.publicGetTicker(params)
        return self.parse_tickers(response, symbols)

    def parse_ohlcv(self, ohlcv_msg, market=None, timeframe='1m', since=None, limit=None):
        # {
        #     'm': 'bar',
        #     's': 'BTC/USDT',
        #     'data':
        #         {
        #             'i': '1',
        #             'ts': 1583901000000,
        #             'o': '7924.98',
        #             'c': '7926.80',
        #             'h': '7926.80',
        #             'l': '7924.98',
        #             'v': '0.32144'
        #         }
        # }
        ohlcv = self.safe_value(ohlcv_msg, 'data', {})
        return [
            self.safe_integer(ohlcv, 'ts'),
            self.safe_float(ohlcv, 'o'),
            self.safe_float(ohlcv, 'h'),
            self.safe_float(ohlcv, 'l'),
            self.safe_float(ohlcv, 'c'),
            self.safe_float(ohlcv, 'v'),
        ]

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'interval': self.timeframes[timeframe],
        }
        # if since and limit are not specified
        # the exchange will return just 1 last candle by default
        duration = self.parse_timeframe(timeframe)
        if since is not None:
            request['from'] = since
            if limit is not None:
                request['to'] = self.sum(since, limit * duration * 1000, 1)
        elif limit is not None:
            request['to'] = self.milliseconds()
            request['from'] = request['to'] - limit * duration * 1000 - 1
        response = self.publicGetBarhist(self.extend(request, params))
        records = self.safe_value(response, 'data', [])
        return self.parse_ohlcvs(records, market, timeframe, since, limit)

    async def parse_trade(self, trade, market=None):
        #
        # publicGetTrades
        #
        #     {
        #         "p": "13.75",  # price
        #         "q": "6.68",  # quantity
        #         "ts": 1528988084944,  # timestamp
        #         "bm": False,  # if True, the buyer is the market maker
        #     }
        #
        # privateGetCashOrderStatus / privateGetMarginOrderStatus / privateGetFuturesOrderStatus
        #
        # {
        #     'seqNum': 4208248561,
        #     'orderId': 'r170adcc717eU123456789bbtmabc3P',
        #     'symbol': 'BTMX/USDT',
        #     'orderType': 'Limit',
        #     'lastExecTime': 1583463823205,
        #     'price': '0.06043',
        #     'orderQty': '100',
        #     'side': 'Buy',
        #     'status': 'Filled',
        #     'avgPx': '0.06043',
        #     'cumFilledQty': '100',
        #     'stopPrice': '',
        #     'errorCode': '',
        #     'cumFee': '0.006043',
        #     'feeAsset': 'USDT',
        #     'execInst': 'NULL_VAL'
        # }

        timestamp = self.safe_integer(trade, 'ts')
        price = self.safe_float(trade, 'p')
        amount = self.safe_float(trade, 'q')
        cost = None
        if (price is not None) and (amount is not None):
            cost = price * amount
        buyerIsMaker = self.safe_value(trade, 'bm')
        symbol = None
        marketId = self.safe_string(trade, 's')
        if marketId is not None:
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
                symbol = market['symbol']
            else:
                baseId, quoteId = market.split('/')
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
        if (symbol is None) and (market is not None):
            symbol = market['symbol']
        fee = None
        feeCost = self.safe_float(trade, 'cumFee')
        if feeCost is not None:
            feeCurrencyId = self.safe_string(trade, 'feeAsset')
            feeCurrencyCode = self.safe_currency_code(feeCurrencyId)
            fee = {
                'cost': feeCost,
                'currency': feeCurrencyCode,
            }
        orderId = self.safe_string(trade, 'orderId')
        side = self.safe_string_lower(trade, 'side')
        if (side is None) and (buyerIsMaker is not None):
            side = 'buy' if buyerIsMaker else 'sell'
        type = self.safe_string_lower(trade, 'orderType')
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': None,
            'order': orderId,
            'type': type,
            'takerOrMaker': None,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['n'] = limit  # currently limited to 100 or fewer
        response = self.publicGetTrades(self.extend(request, params))
        #
        # {'code': 0,
        #  'data': {'m': 'trades',
        #           'symbol': 'BTC/USDT',
        #           'data': [{'p': '7812.61',
        #                     'q': '0.01998',
        #                     'ts': 1583760687790,
        #                     'bm': False, # if True, the buyer is the market maker
        #                     'seqnum': 72057603463162642}]
        #           }
        #  }
        #

        records = self.safe_value(response, 'data', {})
        trades = self.safe_value(records, 'data', [])

        return self.parse_trades(trades, market, since, limit)

    def parse_order_status(self, status):
        statuses = {
            'PendingNew': 'open',
            'New': 'open',
            'PartiallyFilled': 'open',
            'Filled': 'closed',
            'Canceled': 'canceled',
            'Rejected': 'rejected',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        #
        # createOrder
        #
        # {
        #     'symbol': 'BTC/USDT',
        #     'orderType': 'Limit',
        #     'action': 'new',
        #     'timestamp': 1583812256973,
        #     'id': '0e602eb4337d4aebbe3c438f6cc41aee',
        #     'orderId': 'a170c29124378418641348f6cc41aee'
        # }
        #
        # fetchOrder, fetchOpenOrders, fetchClosedOrders
        #
        # {
        #     'avgPx': '9126.75',
        #     'cumFee': '0.002738025',
        #     'cumFilledQty': '0.0005',
        #     'errorCode': '',
        #     'execInst': 'NULL_VAL',
        #     'feeAsset': 'USDT',
        #     'lastExecTime': 1583443804918,
        #     'orderId': 'r170ac9b032cU9490877774sbtcpeAAb',
        #     'orderQty': '0.0005',
        #     'orderType': 'Market',
        #     'price': '8853',
        #     'seqNum': 4204789616,
        #     'side': 'Sell',
        #     'status': 'Filled',
        #     'stopPrice': '',
        #     'symbol': 'BTC-PERP'
        # }
        #
        status = self.parse_order_status(self.safe_string(order, 'status'))
        marketId = self.safe_string(order, 'symbol')
        symbol = None
        if marketId is not None:
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
            else:
                baseId, quoteId = marketId.split('/')
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
        if (symbol is None) and (market is not None):
            symbol = market['symbol']
        timestamp = self.safe_integer(order, 'lastExecTime') or self.safe_integer(order, 'timestamp')

        price = self.safe_float(order, 'price')
        amount = self.safe_float(order, 'orderQty')

        avg_fill_px = self.safe_float(order, 'avgPx')
        filled = self.safe_float(order, 'cumFilledQty')
        remaining = self.amount_to_precision(symbol, max(0, (amount or 0) - (filled or 0)))
        cost = (avg_fill_px or 0) * (filled or 0)
        id = self.safe_string(order, 'orderId')
        type = self.safe_string(order, 'orderType')
        if type is not None:
            type = type.lower()

        side = self.safe_string_lower(order, 'side')
        fee = {
            'cost': self.safe_float(order, 'cumFee'),
            'currency': self.safe_string(order, 'feeAsset'),
        }

        return {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'average': avg_fill_px,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
            'trades': None,
        }

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        self.load_accounts()
        market = self.market(symbol)
        request = {
            'id': self.coid(),  # a unique identifier of length 32
            # 'time': self.milliseconds(),  # milliseconds since UNIX epoch in UTC, self is filled in the private section of the sign() method below
            'symbol': market['id'],
            'orderPrice': self.price_to_precision(symbol, price or 0.0),  # optional, limit price of the order. This field is required for limit orders and stop limit orders
            'stopPrice': self.price_to_precision(symbol, self.safe_value(params, 'stopPrice', 0.0)),  # optional, stopPrice of the order. This field is required for stop_market orders and stop limit orders
            'orderQty': self.amount_to_precision(symbol, amount),
            'orderType': type,  # order type, you shall specify one of the following: "limit", "market", "stop_market", "stop_limit"
            'side': side,  # "buy" or "sell"
            'postOnly': self.safe_value(params, 'postOnly', False),  # optional, if True, the order will either be posted to the limit order book or be cancelled, i.e. the order cannot take liquidity, default is False
            'timeInForce': self.safe_string(params, 'timeInForce', 'GTC') # optional, supports "GTC" good-till-canceled, "IOC" immediate-or-cancel, and "FOK" for fill-or-kill
        }
        if (type == 'limit') or (type == 'stop_limit'):
            request['orderPrice'] = self.price_to_precision(symbol, price)
        response = getattr(self, f'privatePost{self.get_account(params)}Order')(self.extend(request, params))
        #
        #     {
        #         "code": 0,
        #         "email": "foo@bar.com",  # self field will be deprecated soon
        #         "status": "success",  # self field will be deprecated soon
        #         "data": {
        #             "coid": "xxx...xxx",
        #             "action": "new",
        #             "success": True,  # success = True means the order has been submitted to the matching engine
        #         }
        #     }
        #
        data = self.safe_value(response, 'data', {})
        return self.parse_order(self.extend(self.safe_value(data, 'info'), {'status': None}), market)

    async def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        self.load_accounts()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request = {
            'orderId': id,
        }
        try:
            response = self.privateGetCashOrderStatus(self.extend(request, params))
        except ExchangeError:
            try:
                response = self.privateGetMarginOrderStatus(self.extend(request, params))
            except ExchangeError:
                response = self.privateGetFuturesOrderStatus(self.extend(request, params))

        #
        # {'code': 0,
        #  'accountId': 'ABCDEFGHIJKLMNOPQRSTUVWXYZABC',
        #  'ac': 'CASH',
        #  'data': {'seqNum': 4208248561,
        #           'orderId': 'r170adcc717eU123456789bbtmabc3P',
        #           'symbol': 'BTMX/USDT',
        #           'orderType': 'Limit',
        #           'lastExecTime': 1583463823205,
        #           'price': '0.06043',
        #           'orderQty': '100',
        #           'side': 'Buy',
        #           'status': 'Filled',
        #           'avgPx': '0.06043',
        #           'cumFilledQty': '100',
        #           'stopPrice': '',
        #           'errorCode': '',
        #           'cumFee': '0.006043',
        #           'feeAsset': 'USDT',
        #           'execInst': 'NULL_VAL'
        #           }
        #  }
        #

        data = self.safe_value(response, 'data', {})
        return self.parse_order(data, market)

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        self.load_accounts()
        market = None
        request = {
            # 'symbol': 'ETH/BTC',  # optional
            # 'category': 'CASH',  # optional, string
            # 'side': 'buy',  # or 'sell', optional, case insensitive.
            # 'page': 1,  # optional, integer type, starts at 1
            # 'pageSize': 100,  # optional, integer type
            # 'startTime': 1566091628227,  # optional, milliseconds since UNIX epoch for the start of the range
            # 'endTime': 1566091628227,  # optional, milliseconds since UNIX epoch for the end of the range
            # 'status': 'Filled',  # optional, can only be one of "Filled", "Canceled", "Rejected"
        }
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if limit is not None:
            request['n'] = limit  # default 15, max 50
        request['executedOnly'] = self.safe_value(params, 'executedOnly', False)
        response = getattr(self, f'privateGet{self.get_account(params)}OrderHistCurrent')(self.extend(request, params))
        # {
        #     'code': 0,
        #     'accountId': 'test1@xxxxx.io',
        #     'ac': 'CASH',
        #     'data': [
        #         {
        #             'seqNum': 30181890,
        #             'orderId': 'a170c4f6cae084186413483b0e984fe',
        #             'symbol': 'BTC/USDT',
        #             'orderType': 'Limit',
        #             'lastExecTime': 1583852473185,
        #             'price': '8500',
        #             'orderQty': '0.01',
        #             'side': 'Buy',
        #             'status': 'Filled',
        #             'avgPx': '8032.04',
        #             'cumFilledQty': '0.01',
        #             'stopPrice': '',
        #             'errorCode': '',
        #             'cumFee': '0.065862728',
        #             'feeAsset': 'USDT',
        #             'execInst': 'NULL_VAL'
        #         }]
        #  }
        #
        orders = self.safe_value(response, 'data', {})
        return self.parse_orders(orders, market, since, limit)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        self.load_accounts()
        market = None
        request = {
            # 'symbol': 'symbol'  optional
        }
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        response = getattr(self, f'privateGet{self.get_account(params)}OrderOpen')(self.extend(request, params))
        #
        # {
        #     'code': 0,
        #     'accountId': 'MPXFNEYEJIJ93CREXT3LTCIDIJPCFNIX',
        #     'ac': 'CASH',
        #     'data':
        #         [{
        #             'seqNum': 4305977824,
        #             'orderId': 'a170c9e191a7U9490877774397007e73',
        #             'symbol': 'BTMX/USDT',
        #             'orderType': 'Limit',
        #             'lastExecTime': 1583934968446,
        #             'price': '0.045',
        #             'orderQty': '200',
        #             'side': 'Buy',
        #             'status': 'New',
        #             'avgPx': '0',
        #             'cumFilledQty': '0',
        #             'stopPrice': '',
        #             'errorCode': '',
        #             'cumFee': '0',
        #             'feeAsset': 'USDT',
        #             'execInst': 'NULL_VAL'
        #         }]
        # }
        #

        data = self.safe_value(response, 'data', [])
        return self.parse_orders(data, market, since, limit)

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        self.load_accounts()
        market = None
        request = {
            # 'symbol': 'ETH/BTC',  # optional
            # 'category': 'CASH'/'MARGIN'/'FUTURES'  # optional, string
            # 'orderType': 'Market',  # optional, string
            # 'page': 1,  # optional, integer type, starts at 1
            # 'pageSize': 100,  # optional, integer type
            # 'side': 'buy',  # or 'sell', optional, case insensitive.
            # 'startTime': 1566091628227,  # optional, integer milliseconds since UNIX epoch representing the start of the range
            # 'endTime': 1566091628227,  # optional, integer milliseconds since UNIX epoch representing the end of the range
            # 'status': 'Filled',  # optional, can only be one of "Filled", "Canceled", "Rejected"
        }
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['n'] = limit  # default 15, max 50

        response = self.privateGetOrderHist(self.extend(request, params))
        #
        # {
        #     'code': 0,
        #     'data':
        #         {
        #             'page': 1,
        #             'pageSize': 20,
        #             'limit': 500,
        #             'hasNext': True,
        #             'data': [
        #                 {
        #                     'ac': 'CASH',
        #                     'accountId': 'ABCDEFGHIJKLMOPQRSTUVWXYZABC',
        #                     'avgPx': '0',
        #                     'cumFee': '0',
        #                     'cumQty': '0',
        #                     'errorCode': 'NULL_VAL',
        #                     'feeAsset': 'USDT',
        #                     'lastExecTime': 1583894311925,
        #                     'orderId': 'r170c77528bdU9490877774bbtcu9DwL',
        #                     'orderQty': '0.001', 'orderType': 'Limit',
        #                     'price': '7912.88',
        #                     'sendingTime': 1583894310880,
        #                     'seqNum': 4297339552,
        #                     'side': 'Buy',
        #                     'status': 'Canceled',
        #                     'stopPrice': '',
        #                     'symbol': 'BTC/USDT',
        #                     'execInst': 'NULL_VAL'
        #                 }
        #             ]
        #         }
        # }
        #

        data = self.safe_value(response, 'data', {})
        orders = self.safe_value(data, 'data', [])
        return self.parse_orders(orders, market, since, limit)

    async def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder requires a symbol argument')
        self.load_markets()
        self.load_accounts()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'id': self.coid(),
            'orderId': id,
            # 'time': self.milliseconds(),  # self is filled in the private section of the sign() method below
        }
        response = getattr(self, f'privateDelete{self.get_account(params)}Order')(self.extend(request, params))
        #
        # {
        #     'code': 0,
        #     'data':
        #         {
        #             'accountId': 'test1@dengpan.io',
        #             'ac': 'CASH',
        #             'action': 'cancel-order',
        #             'status': 'Ack',
        #             'info': {
        #                 'symbol': 'BTC/USDT',
        #                 'orderType': '',
        #                 'timestamp': 1583868590663,
        #                 'id': 'de4f5a7c5df2433cbe427da14d8f84d5',
        #                 'orderId': 'a170c5136edb8418641348575f38457'}
        #         }
        # }
        #
        order = self.safe_value(self.safe_value(response, 'data', {}), 'info', {})
        order['status'] = None
        return self.parse_order(order)

    async def cancel_all_orders(self, symbol=None, params={}):
        self.load_markets()
        self.load_accounts()
        request = {}
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']  # optional

        response = getattr(self, f'privateDelete{self.get_account(params)}OrderAll')(self.extend(request, params))

        return response

    def coid(self):
        uuid = self.uuid()
        parts = uuid.split('-')
        clientOrderId = ''.join(parts)
        coid = clientOrderId[0:32]
        return coid

    async def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        self.load_accounts()
        currency = self.currency(code)
        request = {
            #'requestId': self.coid(),
            # 'time': self.milliseconds(),  # self is filled in the private section of the sign() method below
            'asset': currency['id'],
        }
        # note: it is highly recommended to use V2 version of self route,
        # especially for assets with multiple block chains such as USDT.
        response = self.privateGetWalletDepositAddress(self.extend(request, params))
        #
        # {
        #     'code': 0,
        #     'data':
        #         {
        #             'asset': 'BTC',
        #             'assetName': 'Bitcoin',
        #             'address':
        #                 [
        #                     {
        #                         'address': '3P5e8M6nQaGPB6zYJ447uGJKCJN2ZkEDLB',
        #                         'destTag': '',
        #                         'tagType': '',
        #                         'tagId': '',
        #                         'chainName': 'Bitcoin',
        #                         'numConfirmations': 3,
        #                         'withdrawalFee': 0.0005,
        #                         'nativeScale': 8,
        #                         'tips': []
        #                     }
        #                 ]
        #         }
        # }
        #

        data = self.safe_value(response, 'data', {})
        address_data = self.safe_value(data, 'address', [])
        if isinstance(address_data, list) and len(address_data) > 0:
            address_data = address_data[0]

        address = self.safe_string(address_data, 'address')
        tag = self.safe_string(address_data, 'destTag')
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': response,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = '/api/pro/' + self.version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()

            if not self.safe_value(params, 'isCommonApi', False):
                accountGroup = self.safe_string(self.options, 'accountGroup')
                if accountGroup is None:
                    if self.accounts is not None:
                        accountGroup = self.accounts[0]['id']
                if accountGroup is not None:
                    url = '/' + accountGroup + url
            query['time'] = str(self.milliseconds())
            auth = query['time']
            headers = {
                'x-auth-key': self.apiKey,
                'x-auth-timestamp': query['time'],
                'Content-Type': 'application/json',
            }

            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'base64')
            headers['x-auth-signature'] = signature
            if method == 'GET':
                if query:
                    url += '?' + self.urlencode(query)
            else:
                body = self.json(query)
        url = self.urls['api'] + url
        res = {'url': url, 'method': method, 'body': body, 'headers': headers}
        return res

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        #
        #     {"code":2100,"message":"ApiKeyFailure"}
        #     {'code': 6010, 'message': 'Not enough balance.'}
        #     {'code': 60060, 'message': 'The order is already filled or canceled.'}
        #
        code = self.safe_string(response, 'code')
        message = self.safe_string(response, 'message')
        error = (code is not None) and (code != '0')
        if error or (message is not None):
            feedback = self.id + ' ' + body
            self.throw_exactly_matched_exception(self.exceptions['exact'], code, feedback)
            self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
            self.throw_broadly_matched_exception(self.exceptions['broad'], message, feedback)
            raise ExchangeError(feedback)  # unknown message

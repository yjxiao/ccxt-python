# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import math
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import DDoSProtection


class bytetrade (Exchange):

    def describe(self):
        return self.deep_extend(super(bytetrade, self).describe(), {
            'id': 'bytetrade',
            'name': 'bytetrade',
            'countries': ['HK'],
            'rateLimit': 500,
            # new metainfo interface
            'has': {
                'fetchCurrencies': True,
                'fetchDepositAddress': True,
                'CORS': False,
                'fetchBidsAsks': True,
                'fetchTickers': True,
                'fetchOHLCV': True,
                'fetchMyTrades': True,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
                'withdraw': True,
                'fetchDeposits': True,
                'fetchWithdrawals': True,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '4h': '4h',
                '1d': '1d',
                '5d': '5d',
                '1w': '1w',
                '1M': '1M',
            },
            'urls': {
                'test': 'https://api-v2-test.bytetrade.com',
                'logo': 'https://user-images.githubusercontent.com/246404/60647143-9c28f880-9e6f-11e9-8b94-fbdd0d3f2c5d.png',
                'api': {
                    'market': 'https://api-v2.bytetrade.com',
                    'public': 'https://api-v2-test.bytetrade.com',
                },
                'www': 'https://www.bytetrade.com',
                'referral': '',
                'doc': 'https://github.com/Bytetrade/bytetrade-official-api-docs/wiki',
            },
            'api': {
                'market': {
                    'get': [
                        'klines',        # Kline of a symbol
                        'depth',         # Market Depth of a symbol
                        'trades',        # Trade records of a symbol
                        'tickers',
                    ],
                },
                'public': {
                    'get': [
                        'symbols',        # Reference information of trading instrument, including base currency, quote precision, etc.
                        'currencies',     # The list of currencies available
                        'balance',        # Get the balance of an account
                        'orders/open',    # Get the open orders of an account
                        'orders/closed',  # Get the closed orders of an account
                        'orders/all',     # Get the open and closed orders of an account
                        'orders',         # Get the details of an order of an account
                        'orders/trades',  # Get detail match results
                        'depositaddress',  # Get deposit address
                        'withdrawals',    # Get withdrawals info
                        'deposits',       # Get deposit info
                        'transfers',      # Get transfer info
                    ],
                    'post': [
                        'transaction/createorder',    # Post create order transaction to blockchain
                        'transaction/cancelorder',    # Post cancel order transaction to blockchain
                        'transaction/withdraw',       # Post withdraw transaction to blockchain
                        'transaction/transfer',       # Post transfer transaction to blockchain
                    ],
                },
                'private': {
                    'get': [
                    ],
                    'post': [
                    ],
                },
            },
            'fees': {
                'trading': {
                    'taker': 0.0008,
                    'maker': 0.0008,
                },
            },
            'commonCurrencies': {
                '48': 'Blocktonic',
            },
            'options': {
            },
            'exceptions': {
                'vertify error': AuthenticationError,           # private key signature is incorrect
                'transaction already in network': BadRequest,   # same transaction submited
                'invalid argument': ArgumentsRequired,
            },
        })

    def fetch_currencies(self, params={}):
        currencies = self.publicGetCurrencies(params)
        result = {}
        for i in range(0, len(currencies)):
            currency = currencies[i]
            id = self.safe_string(currency, 'code')
            code = None
            if id in self.commonCurrencies:
                code = self.commonCurrencies[id]
            else:
                code = self.safe_string(currency, 'name')
            name = self.safe_string(currency, 'fullname')
            # in bytetrade.com DEX, request https://api-v2.bytetrade.com/currencies will return currencies,
            # the api doc is https://github.com/Bytetrade/bytetrade-official-api-docs/wiki/rest-api#get-currencies-get-currencys-supported-in-bytetradecom
            # we can see the coin name is none-unique in the result, the coin which code is 18 is the CyberMiles ERC20, and the coin which code is 35 is the CyberMiles main chain, but their name is same.
            # that is because bytetrade is a DEX, supports people create coin with the same name, but the id(code) of coin is unique, so we should use the id or name and id as the identity of coin.
            # For coin name and symbol is same with CCXT, I use name@id as the key of commonCurrencies dict.
            # [{
            #     "name": "CMT",      # currency name, non-unique
            #     "code": "18",       # currency id, unique
            #     "type": "crypto",
            #     "fullname": "CyberMiles",
            #     "active": True,
            #     "chainType": "ethereum",
            #     "basePrecision": 18,
            #     "transferPrecision": 10,
            #     "externalPrecision": 18,
            #     "chainContractAddress": "0xf85feea2fdd81d51177f6b8f35f0e6734ce45f5f",
            #     "limits": {
            #       "deposit": {
            #         "min": "0",
            #         "max": "-1"
            #       },
            #       "withdraw": {
            #         "min": "0",
            #         "max": "-1"
            #       }
            #     }
            #   },
            #   {
            #     "name": "CMT",
            #     "code": "35",
            #     "type": "crypto",
            #     "fullname": "CyberMiles",
            #     "active": True,
            #     "chainType": "cmt",
            #     "basePrecision": 18,
            #     "transferPrecision": 10,
            #     "externalPrecision": 18,
            #     "chainContractAddress": "0x0000000000000000000000000000000000000000",
            #     "limits": {
            #       "deposit": {
            #         "min": "1",
            #         "max": "-1"
            #       },
            #       "withdraw": {
            #         "min": "10",
            #         "max": "-1"
            #       }
            #     }
            #   }
            #   ]
            active = self.safe_value(currency, 'active')
            limits = self.safe_value(currency, 'limits')
            deposit = self.safe_value(limits, 'deposit')
            precision = self.safe_integer(currency, 'basePrecision')
            maxDeposit = self.safe_float(deposit, 'max')
            if maxDeposit == -1.0:
                maxDeposit = None
            withdraw = self.safe_value(limits, 'withdraw')
            maxWithdraw = self.safe_float(withdraw, 'max')
            if maxWithdraw == -1.0:
                maxWithdraw = None
            result[code] = {
                'id': id,
                'code': code,
                'name': name,
                'active': active,
                'precision': precision,
                'fee': None,
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'deposit': {
                        'min': self.safe_float(deposit, 'min'),
                        'max': maxDeposit,
                    },
                    'withdraw': {
                        'min': self.safe_float(withdraw, 'min'),
                        'max': maxWithdraw,
                    },
                },
                'info': currency,
            }
        return result

    def fetch_markets(self, params={}):
        markets = self.publicGetSymbols(params)
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = self.safe_string(market, 'symbol')
            base = self.safe_currency_code(self.safe_string(market, 'baseName'))
            quote = self.safe_currency_code(self.safe_string(market, 'quoteName'))
            baseId = self.safe_string(market, 'base')
            quoteId = self.safe_string(market, 'quote')
            symbol = base + '/' + quote
            amountMin = self.safe_float(market['limits']['amount'], 'min')
            amountMax = self.safe_float(market['limits']['amount'], 'max')
            priceMin = self.safe_float(market['limits']['price'], 'min')
            priceMax = self.safe_float(market['limits']['price'], 'max')
            precision = {
                'amount': self.safe_integer(market['precision'], 'amount'),
                'price': self.safe_integer(market['precision'], 'price'),
            }
            active = self.safe_string(market, 'active')
            entry = {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': amountMin,
                        'max': amountMax,
                    },
                    'price': {
                        'min': priceMin,
                        'max': priceMax,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
            }
            result.append(entry)
        return result

    def fetch_balance(self, params={}):
        if not('userid' in list(params.keys())) and(self.apiKey is None):
            raise ArgumentsRequired('fetchDeposits requires hasAlreadyAuthenticatedSuccessfully or userid argument')
        self.load_markets()
        request = {
            'userid': self.apiKey,
        }
        balances = self.publicGetBalance(self.extend(request, params))
        result = {'info': balances}
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'code')
            code = self.safe_currency_code(currencyId, None)
            account = self.account()
            account['free'] = self.safe_float(balance, 'free')
            account['used'] = self.safe_float(balance, 'used')
            result[code] = account
        return self.parse_balance(result)

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['limit'] = limit  # default = maximum = 100
        response = self.marketGetDepth(self.extend(request, params))
        timestamp = self.safe_value(response, 'timestamp')
        orderbook = self.parse_order_book(response, timestamp)
        return orderbook

    def parse_ticker(self, ticker, market=None):
        timestamp = self.safe_integer(ticker, 'timestamp')
        symbol = self.find_symbol(self.safe_string(ticker, 'symbol'), market)
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': self.safe_float(ticker, 'weightedAvgPrice'),
            'open': self.safe_float(ticker, 'open'),
            'close': self.safe_float(ticker, 'close'),
            'last': self.safe_float(ticker, 'last'),
            'previousClose': None,  # previous day close
            'change': self.safe_float(ticker, 'change'),
            'percentage': self.safe_float(ticker, 'percentage'),
            'average': None,
            'baseVolume': self.safe_float(ticker, 'baseVolume'),
            'quoteVolume': self.safe_float(ticker, 'quoteVolume'),
            'info': ticker,
        }

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = self.marketGetTickers(self.extend(request, params))
        if len(response) > 0:
            return self.parse_ticker(response[0], market)
        return self.parse_ticker(response, market)

    def parse_tickers(self, rawTickers, symbols=None):
        tickers = []
        for i in range(0, len(rawTickers)):
            tickers.append(self.parse_ticker(rawTickers[i]))
        return self.filter_by_array(tickers, 'symbol', symbols)

    def fetch_bids_asks(self, symbols=None, params={}):
        self.load_markets()
        rawTickers = self.marketGetDepth(params)
        return self.parse_tickers(rawTickers, symbols)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        rawTickers = self.marketGetTickers(params)
        return self.parse_tickers(rawTickers, symbols)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        return [
            ohlcv[0],
            float(ohlcv[1]),
            float(ohlcv[2]),
            float(ohlcv[3]),
            float(ohlcv[4]),
            float(ohlcv[5]),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'timeframe': self.timeframes[timeframe],
        }
        if since is not None:
            request['since'] = since
        if limit is not None:
            request['limit'] = limit
        response = self.marketGetKlines(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_trade(self, trade, market=None):
        timestamp = self.safe_integer_2(trade, 'timestamp', 'timestamp')
        price = self.safe_float_2(trade, 'price', 'price')
        amount = self.safe_float_2(trade, 'amount', 'amount')
        cost = self.safe_float_2(trade, 'cost', 'cost')
        id = self.safe_string_2(trade, 'id', 'id')
        type = self.safe_string_2(trade, 'type', 'type')
        takerOrMaker = self.safe_string_2(trade, 'takerOrMaker', 'takerOrMaker')
        side = self.safe_string_2(trade, 'side', 'side')
        datetime = self.safe_string_2(trade, 'datetime', 'datetime')
        order = self.safe_string_2(trade, 'order', 'order')
        fee = self.safe_value(trade, 'fee')
        symbol = None
        if market is None:
            marketId = self.safe_string(trade, 'symbol')
            market = self.safe_value(self.markets_by_id, marketId)
        if market is not None:
            symbol = market['symbol']
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': datetime,
            'symbol': symbol,
            'id': id,
            'order': order,
            'type': type,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if since is not None:
            request['since'] = since
        if limit is not None:
            request['limit'] = limit  # default = 100, maximum = 500
        response = self.marketGetTrades(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def parse_order(self, order, market=None):
        status = self.safe_string(order, 'status')
        symbol = self.find_symbol(self.safe_string(order, 'symbol'), market)
        timestamp = self.safe_integer(order, 'timestamp')
        datetime = self.safe_string(order, 'datetime')
        lastTradeTimestamp = self.safe_integer(order, 'lastTradeTimestamp')
        price = self.safe_float(order, 'price')
        amount = self.safe_float(order, 'amount')
        filled = self.safe_float(order, 'filled')
        remaining = self.safe_float(order, 'remaining')
        cost = self.safe_float(order, 'cost')
        average = self.safe_float(order, 'average')
        id = self.safe_string(order, 'id')
        type = self.safe_string(order, 'type')
        side = self.safe_string(order, 'side')
        fee = self.safe_value(order, 'fee')
        return {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': datetime,
            'lastTradeTimestamp': lastTradeTimestamp,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'average': average,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
        }

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        if self.apiKey is None:
            raise ArgumentsRequired('createOrder requires hasAlreadyAuthenticatedSuccessfully')
        self.load_markets()
        market = self.market(symbol)
        # the next 5 lines are added to support for testing orders
        sideNum = None
        typeNum = None
        if side == 'sell':
            sideNum = 1
        else:
            sideNum = 2
        if type == 'limit':
            typeNum = 1
        else:
            typeNum = 2
        baseRealName = market['base'].split('@')[0]
        quoteRealName = market['quote'].split('@')[0]
        marketName = baseRealName + '/' + quoteRealName
        baseId = market['baseId']
        baseCurrency = self.currencies_by_id[baseId]
        amountFloat = float(amount)
        amountChainWithoutTruncate = int(amountFloat * math.pow(10, baseCurrency['info']['basePrecision']))
        amountTruncateValue = int(math.pow(10, baseCurrency['info']['basePrecision'] - market['precision']['amount']))
        amountMiddleAfterTruncate = int(amountChainWithoutTruncate / amountTruncateValue)
        amountChain = int(amountMiddleAfterTruncate * amountTruncateValue)
        quoteId = market['quoteId']
        quoteCurrency = self.currencies_by_id[quoteId]
        priceFloat = float(price)
        priceChainWithoutTruncate = int(priceFloat * math.pow(10, quoteCurrency['info']['basePrecision']))
        priceTruncateValue = int(math.pow(10, quoteCurrency['info']['basePrecision'] - market['precision']['price']))
        priceMiddleAfterTruncate = int(priceChainWithoutTruncate / priceTruncateValue)
        priceChain = int(priceMiddleAfterTruncate * priceTruncateValue)
        now = 1567548954000
        expiration = 1567548964000
        datetime = self.iso8601(now)
        datetime = datetime.split('.')[0]
        expiretime = self.iso8601(expiration)
        expiretime = expiretime.split('.')[0]

        operation = {
            'fee': '300000000000000',
            'creator': self.apiKey,
            'side': sideNum,
            'order_type': typeNum,
            'market_name': marketName,
            'amount': str(amountChain),
            'price': str(priceChain),
            'now': now,
            'expiration': expiration,
            'use_btt_as_fee': False,
            'money_id': int(quoteId),
            'stock_id': int(baseId),
        }
        bytestring = Exchange.numberToBE(1, 32)  # chainID
        bytestring += Exchange.numberToLE(now // 1000, 4)
        bytestring += Exchange.numberToLE(1, 1) + Exchange.numberToLE(expiration // 1000, 4)
        bytestring += Exchange.numberToLE(1, 1)  # len(operations)
        bytestring += Exchange.numberToLE(32, 1)  # op_id
        bytestring += Exchange.numberToLE(0, 8) + Exchange.numberToLE(300000000000000, 8)
        bytestring += Exchange.numberToLE(len(self.apiKey), 1) + Exchange.encode(self.apiKey)
        bytestring += Exchange.numberToLE(sideNum, 1)
        bytestring += Exchange.numberToLE(typeNum, 1)
        bytestring += Exchange.numberToLE(len(marketName), 1) + Exchange.encode(marketName)
        bytestring += Exchange.numberToLE(amountChain // 2**64, 8) + Exchange.numberToLE(amountChain % 2**64, 8)
        bytestring += Exchange.numberToLE(priceChain // 2**64, 8) + Exchange.numberToLE(priceChain % 2**64, 8)
        bytestring += Exchange.numberToLE(0, 2)
        bytestring += Exchange.numberToLE(now // 1000, 4)
        bytestring += Exchange.numberToLE(expiration // 1000, 4) + Exchange.numberToLE(0, 2)
        bytestring += Exchange.numberToLE(int(quoteId), 4)
        bytestring += Exchange.numberToLE(int(baseId), 4)
        bytestring += Exchange.numberToLE(0, 1)
        bytestring += Exchange.numberToLE(1, 1)
        bytestring += Exchange.numberToLE(len('Sagittarius'), 1) + Exchange.encode('Sagittarius') + Exchange.numberToLE(0, 1)

        import binascii
        print(binascii.hexlify(bytestring))
        hexs = self.hash(bytestring, 'sha256', 'hex')
        print(hexs)
        signature = self.ecdsa(hexs, self.secret, 'secp256k1', None)
        print(signature)
        mySig = Exchange.numberToLE(signature['v'] + 31, 1).hex() + signature['r'] + signature['s']
        print(priceChain, amountChain)

        #ecdsa = self.ecdsa(json.dumps(ob), self.secret, 'secp256k1', 'sha256')
        signedTransaction = self.signExTransactionV1('create_order', operation, self.secret)
        print(signedTransaction)
        operation['now'] = datetime
        operation['expiration'] = expiretime
        fatty = {
            'timestamp': datetime,
            'expiration': expiretime,
            'operations': [
                [
                    32,
                    operation,
                ],
            ],
            'validate_type': 0,
            'dapp': 'Sagittarius',
            'signatures': [
                mySig,
            ],
        }
        print(json.dumps(fatty))
        request = {
            'trObj': json.dumps(fatty),
        }
        response = self.publicPostTransactionCreateorder(request)
        timestamp = self.milliseconds()
        statusCode = self.safe_string(response, 'code')
        status = ''
        if statusCode == '0':
            status = 'submit success'
        else:
            status = 'submit fail'
        return {
            'info': response,
            'id': '',
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': None,
            'type': None,
            'side': None,
            'price': None,
            'amount': None,
            'filled': None,
            'remaining': None,
            'cost': None,
            'trades': None,
            'fee': None,
        }

    def fetch_order(self, id, symbol=None, params={}):
        if not('userid' in list(params.keys())) and(self.apiKey is None):
            raise ArgumentsRequired('fetchOrder requires hasAlreadyAuthenticatedSuccessfully or userid argument')
        self.load_markets()
        request = {}
        market = None
        if 'userid' in params:
            request['userid'] = params['userid']
        else:
            request['userid'] = self.apiKey
        if symbol is not None:
            market = self.markets[symbol]
            request['symbol'] = market['id']
        request['id'] = id
        response = self.publicGetOrders(self.extend(request, params))
        return self.parse_order(response, market)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        if not('userid' in list(params.keys())) and(self.apiKey is None):
            raise ArgumentsRequired('fetchOpenOrders requires hasAlreadyAuthenticatedSuccessfully or userid argument')
        self.load_markets()
        market = None
        request = {}
        if 'userid' in params:
            request['userid'] = params['userid']
        else:
            request['userid'] = self.apiKey
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if limit is not None:
            request['limit'] = limit
        response = self.publicGetOrdersOpen(self.extend(request, params))
        return self.parse_orders(response, market, since, limit)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        if not('userid' in list(params.keys())) and(self.apiKey is None):
            raise ArgumentsRequired('fetchClosedOrders requires hasAlreadyAuthenticatedSuccessfully or userid argument')
        self.load_markets()
        market = None
        request = {}
        if 'userid' in params:
            request['userid'] = params['userid']
        else:
            request['userid'] = self.apiKey
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if limit is not None:
            request['limit'] = limit
        response = self.publicGetOrdersClosed(self.extend(request, params))
        return self.parse_orders(response, market, since, limit)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if not('userid' in list(params.keys())) and(self.apiKey is None):
            raise ArgumentsRequired('fetchOrders requires hasAlreadyAuthenticatedSuccessfully or userid argument')
        self.load_markets()
        market = None
        request = {}
        if 'userid' in params:
            request['userid'] = params['userid']
        else:
            request['userid'] = self.apiKey
        if symbol is not None:
            market = self.market(symbol)
            request['symbol'] = market['id']
        if limit is not None:
            request['limit'] = limit
        response = self.publicGetOrdersAll(self.extend(request, params))
        return self.parse_orders(response, market, since, limit)

    def cancel_order(self, id, symbol=None, params={}):
        if self.apiKey is None:
            raise ArgumentsRequired('cancelOrder requires hasAlreadyAuthenticatedSuccessfully')
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        baseRealName = market['base'].split('@')[0]
        quoteRealName = market['quote'].split('@')[0]
        marketName = baseRealName + '/' + quoteRealName
        baseId = market['baseId']
        quoteId = market['quoteId']
        ob = {
            'fee': '300000000000000',
            'creator': self.apiKey,
            'order_id': id,
            'market_name': marketName,
            'money_id': int(quoteId),
            'stock_id': int(baseId),
        }
        signedTransaction = self.signExTransactionV1('cancel_order', ob, self.secret)
        request = {
            'trObj': signedTransaction,
        }
        response = self.publicPostTransactionCancelorder(request)
        timestamp = self.milliseconds()
        statusCode = self.safe_string(response, 'code')
        status = ''
        if statusCode == '0':
            status = 'submit success'
        else:
            status = 'submit fail'
        return {
            'info': response,
            'id': '',
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': None,
            'type': None,
            'side': None,
            'price': None,
            'amount': None,
            'filled': None,
            'remaining': None,
            'cost': None,
            'trades': None,
            'fee': None,
        }

    def transfer(self, to, code, amount, params={}):
        if self.apiKey is None:
            raise ArgumentsRequired('transfer requires hasAlreadyAuthenticatedSuccessfully')
        self.load_markets()
        currency = self.currencies[code]
        amountFloat = float(amount)
        amountChainWithoutTruncate = int(amountFloat * math.pow(10, currency['info']['basePrecision']))
        TruncateValue = int(math.pow(10, currency['info']['basePrecision'] - currency['info']['transferPrecision']))
        amountMiddleAfterTruncate = int(amountChainWithoutTruncate / TruncateValue)
        amountChain = int(amountMiddleAfterTruncate * TruncateValue)
        ob = {
            'fee': '300000000000000',
            'from': self.apiKey,
            'to': to,
            'asset_type': int(currency['id']),
            'amount': str(amountChain),
        }
        signedTransaction = self.signExTransactionV1('transfer', ob, self.secret)
        request = {
            'trObj': signedTransaction,
        }
        response = self.publicPostTransactionTransfer(request)
        timestamp = self.milliseconds()
        statusCode = self.safe_string(response, 'code')
        status = ''
        if statusCode == '0':
            status = 'submit success'
        else:
            status = 'submit fail'
        return {
            'info': response,
            'id': '',
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': None,
            'type': None,
            'side': None,
            'price': None,
            'amount': None,
            'filled': None,
            'remaining': None,
            'cost': None,
            'fee': None,
        }

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if not('userid' in list(params.keys())) and(self.apiKey is None):
            raise ArgumentsRequired('fetchMyTrades requires hasAlreadyAuthenticatedSuccessfully or userid argument')
        if symbol is None:
            raise ArgumentsRequired('fetchMyTrades requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {}
        if 'userid' in params:
            request['userid'] = params['userid']
        else:
            request['userid'] = self.apiKey
        if symbol is not None:
            request['symbol'] = market['id']
        if limit is not None:
            request['limit'] = limit
        response = self.publicGetOrdersTrades(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        if not('userid' in list(params.keys())) and(self.apiKey is None):
            raise ArgumentsRequired('fetchDeposits requires hasAlreadyAuthenticatedSuccessfully or userid argument')
        currency = None
        request = {}
        if 'userid' in params:
            request['userid'] = params['userid']
        else:
            request['userid'] = self.apiKey
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
        if since is not None:
            request['since'] = since
        if limit is not None:
            request['limit'] = limit
        response = self.publicGetDeposits(self.extend(request, params))
        return self.parseTransactions(response, currency, since, limit)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        if not('userid' in list(params.keys())) and(self.apiKey is None):
            raise ArgumentsRequired('fetchWithdrawals requires hasAlreadyAuthenticatedSuccessfully or userid argument')
        currency = None
        request = {}
        if 'userid' in params:
            request['userid'] = params['userid']
        else:
            request['userid'] = self.apiKey
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
        if since is not None:
            request['since'] = since
        if limit is not None:
            request['limit'] = limit
        response = self.publicGetWithdrawals(self.extend(request, params))
        return self.parseTransactions(response, currency, since, limit)

    def parse_transaction_status_by_type(self, status):
        if (status == 'DEPOSIT_FAILED') or (status == 'FEE_SEND_FAILED') or (status == 'FEE_FAILED') or (status == 'PAY_SEND_FAILED') or (status == 'PAY_FAILED') or (status == 'BTT_FAILED') or (status == 'WITHDDRAW_FAILED') or (status == 'USER_FAILED'):
            return 'failed'
        elif (status == 'FEE_EXECUED') or (status == 'PAY_EXECUED') or (status == 'WITHDDRAW_EXECUTED') or (status == 'USER_EXECUED'):
            return 'pending'
        elif status == 'BTT_SUCCED':
            return 'ok'
        else:
            return status

    def parse_transaction(self, transaction, currency=None):
        id = self.safe_string(transaction, 'id')
        address = self.safe_string(transaction, 'address')
        tag = self.safe_string(transaction, 'tag')
        if tag is not None:
            if len(tag) < 1:
                tag = None
        txid = self.safe_value(transaction, 'txid')
        currencyId = self.safe_string(transaction, 'code')
        code = self.safe_currency_code(currencyId, currency)
        timestamp = self.safe_integer(transaction, 'timestamp')
        datetime = self.safe_string(transaction, 'datetime')
        type = self.safe_string(transaction, 'type')
        status = self.parse_transaction_status_by_type(self.safe_string(transaction, 'status'))
        amount = self.safe_float(transaction, 'amount')
        feeInfo = self.safe_value(transaction, 'fee')
        feeCost = self.safe_float(feeInfo, 'cost')
        feeCurrencyId = self.safe_string(feeInfo, 'code')
        feeCode = self.safe_currency_code(feeCurrencyId, currency)
        fee = {
            'cost': feeCost,
            'currency': feeCode,
        }
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': datetime,
            'address': address,
            'tag': tag,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': None,
            'fee': fee,
        }

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        if not('userid' in list(params.keys())) and(self.apiKey is None):
            raise ArgumentsRequired('fetchDepositAddress requires hasAlreadyAuthenticatedSuccessfully or userid argument')
        currency = self.currency(code)
        request = {}
        if 'userid' in params:
            request['userid'] = params['userid']
        else:
            request['userid'] = self.apiKey
        request['code'] = currency['id']
        response = self.publicGetDepositaddress(request)
        address = self.safe_string(response[0], 'address')
        tag = self.safe_string(response[0], 'addressTag')
        chainType = self.safe_string(response[0], 'chainType')
        self.check_address(address)
        return {
            'currency': code,
            'address': self.check_address(address),
            'tag': tag,
            'chainType': chainType,
            'info': response,
        }

    def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        self.load_markets()
        if self.apiKey is None:
            raise ArgumentsRequired('withdraw requires hasAlreadyAuthenticatedSuccessfully')
        # when deposit, first deposit to user's pixiu address, and then auto transfer to bytetrade smart contract from pixiu addreess; when withdraw, first withdraw to user's pixiu address from bytetrade smart contract, and then transfer to user address
        addressResponse = self.fetch_deposit_address(code)
        middleAddress = self.safe_string(addressResponse, 'address')
        chainTypeString = self.safe_string(addressResponse, 'chainType')
        chainType = 0
        assetFee = 0
        if chainTypeString == 'ethereum':
            chainType = 1
        elif chainTypeString == 'bitcoin':
            chainType = 2
        elif chainTypeString == 'cmt':
            chainType = 3
        elif chainTypeString == 'naka':
            chainType = 4
        currency = self.currency(code)
        coinId = currency['id']
        Currency = self.currencies_by_id[coinId]
        amountFloat = float(amount)
        amountChain = int(amountFloat * math.pow(10, currency['info']['externalPrecision']))
        signedTransaction = ''
        if chainTypeString == 'bitcoin':
            assetFee = currency['info']['fee']
            ob = {
                'fee': '300000000000000',
                'from': self.apiKey,
                'to_external_address': middleAddress,
                'asset_type': int(coinId),
                'amount': str(amountChain),
                'asset_fee': str(assetFee),
            }
            signedTransaction = self.signExTransactionV1('btc_withdraw', ob, self.secret)
        else:
            ob = {
                'fee': '300000000000000',
                'from': self.apiKey,
                'to_external_address': middleAddress,
                'asset_type': int(coinId),
                'amount': str(amountChain),
            }
            signedTransaction = self.signExTransactionV1('withdraw', ob, self.secret)
        request = {}
        request['chainType'] = chainType
        request['toExternalAddress'] = address
        request['trObj'] = signedTransaction
        request['chainContractAddress'] = self.safe_string(Currency['info'], 'chainContractAddress')
        response = self.publicPostTransactionWithdraw(request)
        return {
            'info': response,
            'id': self.safe_string(response, 'id'),
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api]
        url += '/' + path
        if params:
            url += '?' + self.urlencode(params)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if (code == 503):
            raise DDoSProtection(self.id + ' ' + str(code) + ' ' + reason + ' ' + body)
        if response is None:
            return  # fallback to default error handler
        if 'code' in response:
            status = self.safe_string(response, 'code')
            if status == '1':
                msg = self.safe_string(response, 'msg')
                feedback = self.id + ' ' + self.json(response)
                exceptions = self.exceptions
                if msg in exceptions:
                    raise exceptions[msg](feedback)
                raise ExchangeError(feedback)

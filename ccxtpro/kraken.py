# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support as ccxt
import hashlib


class kraken(ccxt.kraken):

    def describe(self):
        return self.deep_extend(super(kraken, self).describe(), {
            'has': {
                'ws': True,
                'fetchWsTicker': True,
                'fetchWsOrderBook': True,
            },
            'urls': {
                'api': {
                    'ws': 'wss://ws.kraken.com',
                    'wsauth': 'wss://ws-auth.kraken.com',
                    'betaws': 'wss://beta-ws.kraken.com',
                },
            },
            'versions': {
                'ws': '0.2.0',
            },
            'options': {
                'subscriptionStatusByChannelId': {},
            },
        })

    def handle_ws_ticker(self, client, response):
        data = response[2]
        market = self.safe_value(self.options['marketsByNumericId'], str(data[0]))
        symbol = self.safe_string(market, 'symbol')
        return {
            'info': response,
            'symbol': symbol,
            'last': float(data[1]),
            'ask': float(data[2]),
            'bid': float(data[3]),
            'change': float(data[4]),
            'baseVolume': float(data[5]),
            'quoteVolume': float(data[6]),
            'active': False if data[7] else True,
            'high': float(data[8]),
            'low': float(data[9]),
        }

    async def fetch_ws_balance(self, params={}):
        await self.load_markets()
        self.balance = await self.fetchBalance(params)
        channelId = '1000'
        subscribe = {
            'command': 'subscribe',
            'channel': channelId,
        }
        messageHash = channelId + ':b:e'
        url = self.urls['api']['ws']
        return self.sendWsMessage(url, messageHash, subscribe, channelId)

    async def fetch_ws_tickers(self, symbols=None, params={}):
        await self.load_markets()
        # rewrite
        raise NotImplemented(self.id + 'fetchWsTickers not implemented yet')
        # market = self.market(symbol)
        # numericId = str(market['info']['id'])
        # url = self.urls['api']['websocket']['public']
        # return await self.WsTickerMessage(url, '1002' + numericId, {
        #     'command': 'subscribe',
        #     'channel': 1002,
        # })

    async def fetch_ws_trades(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        numericId = self.safe_string(market, 'numericId')
        messageHash = numericId + ':trades'
        url = self.urls['api']['ws']
        subscribe = {
            'command': 'subscribe',
            'channel': numericId,
        }
        return self.sendWsMessage(url, messageHash, subscribe, numericId)

    async def load_markets(self, reload=False, params={}):
        markets = await super(kraken, self).load_markets(reload, params)
        marketsByWsName = self.safe_value(self.options, 'marketsByWsName')
        if (marketsByWsName is None) or reload:
            marketsByWsName = {}
            for i in range(0, len(self.symbols)):
                symbol = self.symbols[i]
                market = self.markets[symbol]
                info = self.safe_value(market, 'info', {})
                wsName = self.safe_string(info, 'wsname')
                marketsByWsName[wsName] = market
            self.options['marketsByWsName'] = marketsByWsName
        return markets

    async def fetch_ws_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        wsName = self.safe_value(market['info'], 'wsname')
        name = 'book'
        messageHash = wsName + ':' + name
        url = self.urls['api']['ws']
        subscribe = {
            'event': 'subscribe',
            'pair': [
                wsName,
            ],
            'subscription': {
                'name': name,
            },
        }
        if limit is not None:
            subscribe['subscription']['depth'] = limit  # default 10, valid options 10, 25, 100, 500, 1000
        return self.sendWsMessage(url, messageHash, subscribe, messageHash)

    async def fetch_ws_heartbeat(self, params={}):
        await self.load_markets()
        channelId = '1010'
        url = self.urls['api']['ws']
        return self.sendWsMessage(url, channelId)

    def sign_ws_message(self, client, messageHash, message, params={}):
        if messageHash.find('1000') == 0:
            reload = False
            if self.check_required_credentials(reload):
                nonce = self.nonce()
                payload = self.urlencode({'nonce': nonce})
                signature = self.hmac(self.encode(payload), self.encode(self.secret), hashlib.sha512)
                message = self.extend(message, {
                    'key': self.apiKey,
                    'payload': payload,
                    'sign': signature,
                })
        return message

    def handle_ws_heartbeat(self, client, message):
        #
        # every second
        #
        #     [1010]
        #
        channelId = '1010'
        self.resolveWsFuture(client, channelId, message)

    def parse_ws_trade(self, client, trade, market=None):
        #
        # public trades
        #
        #     [
        #         "t",  # trade
        #         "42706057",  # id
        #         1,  # 1 = buy, 0 = sell
        #         "0.05567134",  # price
        #         "0.00181421",  # amount
        #         1522877119,  # timestamp
        #     ]
        #
        id = str(trade[1])
        side = 'buy' if trade[2] else 'sell'
        price = float(trade[3])
        amount = float(trade[4])
        timestamp = trade[5] * 1000
        symbol = None
        if market is not None:
            symbol = market['symbol']
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': None,
            'type': None,
            'takerOrMaker': None,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': price * amount,
            'fee': None,
        }

    def handle_ws_order_book(self, client, message):
        #
        # first message(snapshot)
        #
        #     [
        #         0,  # channelID
        #         {
        #             "as": [
        #                 ["5541.30000", "2.50700000", "1534614248.123678"],
        #                 ["5541.80000", "0.33000000", "1534614098.345543"],
        #                 ["5542.70000", "0.64700000", "1534614244.654432"]
        #             ],
        #             "bs": [
        #                 ["5541.20000", "1.52900000", "1534614248.765567"],
        #                 ["5539.90000", "0.30000000", "1534614241.769870"],
        #                 ["5539.50000", "5.00000000", "1534613831.243486"]
        #             ]
        #         },
        #         "book-100",
        #         "XBT/USD"
        #     ]
        #
        # subsequent updates
        #
        #     [
        #         1234,
        #         { # optional
        #             "a": [
        #                 ["5541.30000", "2.50700000", "1534614248.456738"],
        #                 ["5542.50000", "0.40100000", "1534614248.456738"]
        #             ]
        #         },
        #         { # optional
        #             "b": [
        #                 ["5541.30000", "0.00000000", "1534614335.345903"]
        #             ]
        #         },
        #         "book-10",
        #         "XBT/USD"
        #     ]
        #
        messageLength = len(message)
        wsName = message[messageLength - 1]
        market = self.safe_value(self.options['marketsByWsName'], wsName)
        symbol = market['symbol']
        timestamp = None
        messageHash = wsName + ':book'
        # if self is a snapshot
        if 'as' in message[1]:
            # todo get depth from marketsByWsName
            self.orderbooks[symbol] = self.limitedOrderBook({}, 10)
            orderbook = self.orderbooks[symbol]
            sides = {
                'as': 'asks',
                'bs': 'bids',
            }
            keys = list(sides.keys())
            for i in range(0, len(keys)):
                key = keys[i]
                side = sides[key]
                bookside = orderbook[side]
                deltas = self.safe_value(message[1], key, [])
                timestamp = self.handle_ws_deltas(deltas, bookside, timestamp)
            orderbook['timestamp'] = timestamp
            self.resolveWsFuture(client, messageHash, orderbook.limit())
        else:
            orderbook = self.orderbooks[symbol]
            # else, if self is an orderbook update
            a = None
            b = None
            if messageLength == 5:
                a = self.safe_value(message[1], 'a', [])
                b = self.safe_value(message[2], 'b', [])
            else:
                if 'a' in message[1]:
                    a = self.safe_value(message[1], 'a', [])
                else:
                    b = self.safe_value(message[1], 'b', [])
            if a is not None:
                timestamp = self.handle_ws_deltas(a, orderbook['asks'], timestamp)
            if b is not None:
                timestamp = self.handle_ws_deltas(b, orderbook['bids'], timestamp)
            orderbook['timestamp'] = timestamp
            self.resolveWsFuture(client, messageHash, orderbook.limit())

    def handle_ws_deltas(self, deltas, bookside, timestamp):
        for j in range(0, len(deltas)):
            delta = deltas[j]
            price = delta[0]  # no need to conver the price here
            amount = float(delta[1])
            timestamp = max(timestamp or 0, int(delta[2] * 1000))
            bookside.store(price, amount)
        return timestamp

    def handle_ws_system_status(self, client, message):
        #
        #     {
        #         connectionID: 15527282728335292000,
        #         event: 'systemStatus',
        #         status: 'online',
        #         version: '0.2.0'
        #     }
        #
        return message

    def handle_ws_subscription_status(self, client, message):
        #
        #     {
        #         channelID: 210,
        #         channelName: 'book-10',
        #         event: 'subscriptionStatus',
        #         pair: 'ETH/XBT',
        #         status: 'subscribed',
        #         subscription: {depth: 10, name: 'book'}
        #     }
        #
        channelId = self.safe_string(message, 'channelID')
        self.options['subscriptionStatusByChannelId'][channelId] = message

    def handle_ws_message(self, client, message):
        if isinstance(message, list):
            channelId = str(message[0])
            subscriptionStatus = self.safe_value(self.options['subscriptionStatusByChannelId'], channelId)
            if subscriptionStatus is not None:
                subscription = self.safe_value(subscriptionStatus, 'subscription', {})
                name = self.safe_string(subscription, 'name')
                methods = {
                    'book': 'handleWsOrderBook',
                }
                method = self.safe_string(methods, name)
                if method is None:
                    return message
                else:
                    return getattr(self, method)(client, message)
        else:
            event = self.safe_string(message, 'event')
            methods = {
                'systemStatus': 'handleWsSystemStatus',
                'subscriptionStatus': 'handleWsSubscriptionStatus',
            }
            method = self.safe_string(methods, event)
            if method is None:
                return message
            else:
                return getattr(self, method)(client, message)

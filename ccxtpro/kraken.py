# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support as ccxt
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol


class kraken(ccxt.kraken):

    def describe(self):
        return self.deep_extend(super(kraken, self).describe(), {
            'has': {
                'ws': True,
                'fetchWsTicker': True,
                'fetchWsOrderBook': True,
            },
            'urls': {
                'api': {
                    'ws': 'wss://ws.kraken.com',
                    'wsauth': 'wss://ws-auth.kraken.com',
                    'betaws': 'wss://beta-ws.kraken.com',
                },
            },
            'versions': {
                'ws': '0.2.0',
            },
            'options': {
                'subscriptionStatusByChannelId': {},
            },
            'exceptions': {
                'ws': {
                    'exact': {
                        'Event(s) not found': BadRequest,
                    },
                    'broad': {
                        'Currency pair not in ISO 4217-A3 format': BadSymbol,
                    },
                },
            },
        })

    def handle_ws_ticker(self, client, message):
        #
        #     [
        #         0,  # channelID
        #         {
        #             "a": ["5525.40000", 1, "1.000"],  # ask, wholeAskVolume, askVolume
        #             "b": ["5525.10000", 1, "1.000"],  # bid, wholeBidVolume, bidVolume
        #             "c": ["5525.10000", "0.00398963"],  # closing price, volume
        #             "h": ["5783.00000", "5783.00000"],  # high price today, high price 24h ago
        #             "l": ["5505.00000", "5505.00000"],  # low price today, low price 24h ago
        #             "o": ["5760.70000", "5763.40000"],  # open price today, open price 24h ago
        #             "p": ["5631.44067", "5653.78939"],  # vwap today, vwap 24h ago
        #             "t": [11493, 16267],  # number of trades today, 24 hours ago
        #             "v": ["2634.11501494", "3591.17907851"],  # volume today, volume 24 hours ago
        #         },
        #         "ticker",
        #         "XBT/USD"
        #     ]
        #
        print(message)
        print(client.futures)
        print(self.options['subscriptionStatusByChannelId'])
        print('--------------------------------------------------------')
        # resolve all futures having self symbol
        # sys.exit()
        # data = message[2]
        # market = self.safe_value(self.options['marketsByNumericId'], str(data[0]))
        # symbol = self.safe_string(market, 'symbol')
        # return {
        #     'symbol': symbol,
        #     'timestamp': timestamp,
        #     'datetime': self.iso8601(timestamp),
        #     'high': float(ticker['h'][1]),
        #     'low': float(ticker['l'][1]),
        #     'bid': float(ticker['b'][0]),
        #     'bidVolume': None,
        #     'ask': float(ticker['a'][0]),
        #     'askVolume': None,
        #     'vwap': vwap,
        #     'open': self.safe_float(ticker, 'o'),
        #     'close': last,
        #     'last': last,
        #     'previousClose': None,
        #     'change': None,
        #     'percentage': None,
        #     'average': None,
        #     'baseVolume': baseVolume,
        #     'quoteVolume': quoteVolume,
        #     'info': ticker,
        # }

    async def fetch_ws_balance(self, params={}):
        await self.load_markets()
        raise NotImplemented(self.id + ' fetchWsBalance() not implemented yet')

    async def fetch_ws_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        wsName = self.safe_value(market['info'], 'wsname')
        name = 'ticker'
        messageHash = wsName + ':' + name
        url = self.urls['api']['ws']
        requestId = self.nonce()
        subscribe = {
            'foo': 'bar',
            'reqid': requestId,
        }
        # subscribe = {
        #     'event': 'subscribe',
        #     'reqid': requestId,
        #     'pair': [
        #         'foobar',  # wsName,
        #     ],
        #     'subscription': {
        #         'name': name,
        #     },
        # }
        future = self.sendWsMessage(url, messageHash, self.extend(subscribe, params), messageHash)
        client = self.clients[url]
        client['futures'][requestId] = future
        return future

    async def fetch_ws_trades(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        numericId = self.safe_string(market, 'numericId')
        messageHash = numericId + ':trades'
        url = self.urls['api']['ws']
        subscribe = {
            'command': 'subscribe',
            'channel': numericId,
        }
        return self.sendWsMessage(url, messageHash, subscribe, numericId)

    async def load_markets(self, reload=False, params={}):
        markets = await super(kraken, self).load_markets(reload, params)
        marketsByWsName = self.safe_value(self.options, 'marketsByWsName')
        if (marketsByWsName is None) or reload:
            marketsByWsName = {}
            for i in range(0, len(self.symbols)):
                symbol = self.symbols[i]
                market = self.markets[symbol]
                if not market['darkpool']:
                    info = self.safe_value(market, 'info', {})
                    wsName = self.safe_string(info, 'wsname')
                    marketsByWsName[wsName] = market
            self.options['marketsByWsName'] = marketsByWsName
        return markets

    async def fetch_ws_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        wsName = self.safe_value(market['info'], 'wsname')
        name = 'book'
        messageHash = wsName + ':' + name
        url = self.urls['api']['ws']
        subscribe = {
            'event': 'subscribe',
            'pair': [
                wsName,
            ],
            'subscription': {
                'name': name,
            },
        }
        if limit is not None:
            subscribe['subscription']['depth'] = limit  # default 10, valid options 10, 25, 100, 500, 1000
        return self.sendWsMessage(url, messageHash, subscribe, messageHash)

    async def fetch_ws_heartbeat(self, params={}):
        await self.load_markets()
        channelId = '1010'
        url = self.urls['api']['ws']
        return self.sendWsMessage(url, channelId)

    def sign_ws_message(self, client, messageHash, message, params={}):
        if messageHash.find('1000') == 0:
            reload = False
            if self.check_required_credentials(reload):
                nonce = self.nonce()
                payload = self.urlencode({'nonce': nonce})
                signature = self.hmac(self.encode(payload), self.encode(self.secret), hashlib.sha512)
                message = self.extend(message, {
                    'key': self.apiKey,
                    'payload': payload,
                    'sign': signature,
                })
        return message

    def handle_ws_heartbeat(self, client, message):
        #
        # every second
        #
        #     [1010]
        #
        channelId = '1010'
        self.resolveWsFuture(client, channelId, message)

    def parse_ws_trade(self, client, trade, market=None):
        #
        # public trades
        #
        #     [
        #         "t",  # trade
        #         "42706057",  # id
        #         1,  # 1 = buy, 0 = sell
        #         "0.05567134",  # price
        #         "0.00181421",  # amount
        #         1522877119,  # timestamp
        #     ]
        #
        id = str(trade[1])
        side = 'buy' if trade[2] else 'sell'
        price = float(trade[3])
        amount = float(trade[4])
        timestamp = trade[5] * 1000
        symbol = None
        if market is not None:
            symbol = market['symbol']
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': None,
            'type': None,
            'takerOrMaker': None,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': price * amount,
            'fee': None,
        }

    def handle_ws_order_book(self, client, message):
        #
        # first message(snapshot)
        #
        #     [
        #         1234,  # channelID
        #         {
        #             "as": [
        #                 ["5541.30000", "2.50700000", "1534614248.123678"],
        #                 ["5541.80000", "0.33000000", "1534614098.345543"],
        #                 ["5542.70000", "0.64700000", "1534614244.654432"]
        #             ],
        #             "bs": [
        #                 ["5541.20000", "1.52900000", "1534614248.765567"],
        #                 ["5539.90000", "0.30000000", "1534614241.769870"],
        #                 ["5539.50000", "5.00000000", "1534613831.243486"]
        #             ]
        #         },
        #         "book-10",
        #         "XBT/USD"
        #     ]
        #
        # subsequent updates
        #
        #     [
        #         1234,
        #         { # optional
        #             "a": [
        #                 ["5541.30000", "2.50700000", "1534614248.456738"],
        #                 ["5542.50000", "0.40100000", "1534614248.456738"]
        #             ]
        #         },
        #         { # optional
        #             "b": [
        #                 ["5541.30000", "0.00000000", "1534614335.345903"]
        #             ]
        #         },
        #         "book-10",
        #         "XBT/USD"
        #     ]
        #
        messageLength = len(message)
        wsName = message[messageLength - 1]
        market = self.safe_value(self.options['marketsByWsName'], wsName)
        symbol = market['symbol']
        timestamp = None
        messageHash = wsName + ':book'
        # if self is a snapshot
        if 'as' in message[1]:
            # todo get depth from marketsByWsName
            self.orderbooks[symbol] = self.limitedOrderBook({}, 10)
            orderbook = self.orderbooks[symbol]
            sides = {
                'as': 'asks',
                'bs': 'bids',
            }
            keys = list(sides.keys())
            for i in range(0, len(keys)):
                key = keys[i]
                side = sides[key]
                bookside = orderbook[side]
                deltas = self.safe_value(message[1], key, [])
                timestamp = self.handle_ws_deltas(deltas, bookside, timestamp)
            orderbook['timestamp'] = timestamp
            self.resolveWsFuture(client, messageHash, orderbook.limit())
        else:
            orderbook = self.orderbooks[symbol]
            # else, if self is an orderbook update
            a = None
            b = None
            if messageLength == 5:
                a = self.safe_value(message[1], 'a', [])
                b = self.safe_value(message[2], 'b', [])
            else:
                if 'a' in message[1]:
                    a = self.safe_value(message[1], 'a', [])
                else:
                    b = self.safe_value(message[1], 'b', [])
            if a is not None:
                timestamp = self.handle_ws_deltas(a, orderbook['asks'], timestamp)
            if b is not None:
                timestamp = self.handle_ws_deltas(b, orderbook['bids'], timestamp)
            orderbook['timestamp'] = timestamp
            self.resolveWsFuture(client, messageHash, orderbook.limit())

    def handle_ws_deltas(self, deltas, bookside, timestamp):
        for j in range(0, len(deltas)):
            delta = deltas[j]
            price = delta[0]  # no need to conver the price here
            amount = float(delta[1])
            timestamp = max(timestamp or 0, int(delta[2] * 1000))
            bookside.store(price, amount)
        return timestamp

    def handle_ws_status(self, client, message):
        #
        #     {
        #         connectionID: 15527282728335292000,
        #         event: 'systemStatus',
        #         status: 'online',  # online|maintenance|(custom status tbd)
        #         version: '0.2.0'
        #     }
        #
        return message

    def handle_ws_subscription_status(self, client, message):
        #
        # todo: answer the question whether self method should be renamed
        # and unified as handleWsResponse for any usage pattern that
        # involves an identified request/response sequence
        #
        #     {
        #         channelID: 210,
        #         channelName: 'book-10',
        #         event: 'subscriptionStatus',
        #         reqid: 1574146735269,
        #         pair: 'ETH/XBT',
        #         status: 'subscribed',
        #         subscription: {depth: 10, name: 'book'}
        #     }
        #
        channelId = self.safe_string(message, 'channelID')
        self.options['subscriptionStatusByChannelId'][channelId] = message
        requestId = self.safe_string(message, 'reqid')
        if client.futures[requestId]:
            # todo: transpile del in ccxt
            del client.futures[requestId]

    def handle_ws_errors(self, client, message):
        #
        #     {
        #         errorMessage: 'Currency pair not in ISO 4217-A3 format foobar',
        #         event: 'subscriptionStatus',
        #         pair: 'foobar',
        #         reqid: 1574146735269,
        #         status: 'error',
        #         subscription: {name: 'ticker'}
        #     }
        #
        errorMessage = self.safe_value(message, 'errorMessage')
        if errorMessage is not None:
            requestId = self.safe_value(message, 'reqid')
            if requestId is not None:
                broad = self.exceptions['ws']['broad']
                broadKey = self.findBroadlyMatchedKey(broad, errorMessage)
                exception = None
                if broadKey is None:
                    exception = ExchangeError(errorMessage)
                else:
                    exception = broad[broadKey](errorMessage)
                # print(requestId, exception)
                self.rejectWsFuture(client, requestId, exception)
                # raise exception
                return False
        return True

    def handle_ws_message(self, client, message):
        # print(message)
        if isinstance(message, list):
            channelId = str(message[0])
            subscriptionStatus = self.safe_value(self.options['subscriptionStatusByChannelId'], channelId)
            if subscriptionStatus is not None:
                subscription = self.safe_value(subscriptionStatus, 'subscription', {})
                name = self.safe_string(subscription, 'name')
                methods = {
                    'book': 'handleWsOrderBook',
                    'ticker': 'handleWsTicker',
                }
                method = self.safe_string(methods, name)
                if method is None:
                    return message
                else:
                    return getattr(self, method)(client, message)
        else:
            if self.handle_ws_errors(client, message):
                event = self.safe_string(message, 'event')
                methods = {
                    'systemStatus': 'handleWsSystemStatus',
                    'subscriptionStatus': 'handleWsSubscriptionStatus',
                }
                method = self.safe_string(methods, event)
                if method is None:
                    return message
                else:
                    return getattr(self, method)(client, message)

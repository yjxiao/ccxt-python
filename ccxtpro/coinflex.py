# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxtpro.base.exchange import Exchange
import ccxt.async_support as ccxt
from ccxtpro.base.cache import ArrayCache, ArrayCacheBySymbolById, ArrayCacheByTimestamp
import hashlib
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds


class coinflex(Exchange, ccxt.coinflex):

    def describe(self):
        return self.deep_extend(super(coinflex, self).describe(), {
            'has': {
                'ws': True,
                'watchBalance': True,
                'watchMyTrades': True,
                'watchOHLCV': True,
                'watchOrderBook': True,
                'watchOrders': True,
                'watchTicker': True,
                'watchTickers': False,  # for now
                'watchTrades': True,
            },
            'urls': {
                'api': {
                    'ws': 'wss://v2api.coinflex.com/v2/websocket',
                },
                'test': {
                    'ws': 'wss://v2stgapi.coinflex.com/v2/websocket',
                },
            },
            'options': {
            },
            'exceptions': {
                'ws': {
                    'exact': {
                        '20000': AuthenticationError,  # {event: 'login', success: False,  message: 'Signature is invalid', code: '20000', timestamp: '1652709878447'}
                        '710003': BadRequest,  # {event: 'placeorder', submitted: False, tag: '1652714023869', message: 'FAILED sanity bound check as price(14000) > upper bound(13260)', code: '710003', timestamp: '1652714024078'}
                        '710006': InsufficientFunds,  # {event: 'placeorder', submitted: False, tag: '1652788574125', message: 'FAILED balance check as balance(46.8941381080) < value(3152.800)', code: '710006', timestamp: '1652788574376'}
                    },
                },
            },
        })

    async def watch_ticker(self, symbol, params={}):
        channel = 'ticker'
        await self.load_markets()
        market = self.market(symbol)
        messageHash = channel + ':' + market['id']
        return await self.watch_public(messageHash, messageHash, params)

    def handle_ticker(self, client, message):
        #
        #     {
        #         table: 'ticker',
        #         data: [
        #           {
        #             last: '29586',
        #             open24h: '29718',
        #             high24h: '31390',
        #             low24h: '29299',
        #             volume24h: '30861108.9365753390',
        #             currencyVolume24h: '1017.773',
        #             openInterest: '0',
        #             marketCode: 'BTC-USD',
        #             timestamp: '1652693831002',
        #             lastQty: '0.001',
        #             markPrice: '29586',
        #             lastMarkPrice: '29601'
        #           }
        #         ]
        #     }
        #
        topic = self.safe_string(message, 'table')
        tickers = self.safe_value(message, 'data', [])
        for i in range(0, len(tickers)):
            data = tickers[i]
            marketId = self.safe_string(data, 'marketCode')
            market = self.safe_market(marketId, None)
            messageHash = topic + ':' + marketId
            ticker = self.parse_ws_ticker(data, market)
            symbol = ticker['symbol']
            self.tickers[symbol] = ticker
            client.resolve(ticker, messageHash)
        return message

    def parse_ws_ticker(self, ticker, market=None):
        #
        #    {
        #        last: '29586',
        #        open24h: '29718',
        #        high24h: '31390',
        #        low24h: '29299',
        #        volume24h: '30861108.9365753390',
        #        currencyVolume24h: '1017.773',
        #        openInterest: '0',
        #        marketCode: 'BTC-USD',
        #        timestamp: '1652693831002',
        #        lastQty: '0.001',
        #        markPrice: '29586',
        #        lastMarkPrice: '29601'
        #    }
        #
        timestamp = self.safe_integer(ticker, 'timestamp')
        marketId = self.safe_string(ticker, 'marketCode')
        market = self.safe_market(marketId, market)
        close = self.safe_string(ticker, 'last')
        open = self.safe_string(ticker, 'open24h')
        high = self.safe_string(ticker, 'high24h')
        low = self.safe_string(ticker, 'low24h')
        baseVolume = self.safe_string(ticker, 'currencyVolume24h')
        return self.safe_ticker({
            'symbol': market['symbol'],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': high,
            'low': low,
            'bid': None,
            'bidVolume': None,
            'ask': None,
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': close,
            'last': close,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': None,
            'info': ticker,
        }, market)

    async def watch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        channel = 'candles'
        await self.load_markets()
        market = self.market(symbol)
        symbol = market['symbol']
        interval = self.timeframes[timeframe]
        messageHash = channel + interval + ':' + market['id']
        ohlcv = await self.watch_public(messageHash, messageHash, params)
        if self.newUpdates:
            limit = ohlcv.getLimit(symbol, limit)
        return self.filter_by_since_limit(ohlcv, since, limit, 0, True)

    def handle_ohlcv(self, client, message):
        #
        #     "table":"candles60s",
        #     "data":[
        #        {
        #           "candle":[
        #              "1652695200000",
        #              "29598",
        #              "29598",
        #              "29597.585628",
        #              "29597.585628",
        #              "1589597.531322996",
        #              "53.707"
        #           ],
        #           "marketCode":"BTC-USD"
        #        }
        #     ]
        #  }
        #
        topic = self.safe_string(message, 'table')
        interval = topic.replace('candles', '')
        data = self.safe_value(message, 'data', [])
        for i in range(0, len(data)):
            entry = data[i]
            candles = self.safe_value(entry, 'candle', [])
            marketId = self.safe_string(entry, 'marketCode')
            market = self.safe_market(marketId, None)
            messageHash = topic + ':' + marketId
            symbol = market['symbol']
            timeframe = self.find_timeframe(interval)
            ohlcvs = self.parse_ws_ohlcv(candles, market)
            self.ohlcvs[symbol] = self.safe_value(self.ohlcvs, symbol, {})
            stored = self.safe_value(self.ohlcvs[symbol], timeframe)
            if stored is None:
                limit = self.safe_integer(self.options, 'OHLCVLimit', 1000)
                stored = ArrayCacheByTimestamp(limit)
                self.ohlcvs[symbol][timeframe] = stored
            stored.append(ohlcvs)
            client.resolve(stored, messageHash)

    def parse_ws_ohlcv(self, ohlcv, market=None):
        #
        #  [
        #     "1652695200000",
        #     "29598",
        #     "29598",
        #     "29597.585628",
        #     "29597.585628",
        #     "1589597.531322996",
        #     "53.707"
        #  ]
        #
        return [
            self.safe_number(ohlcv, 0),
            self.safe_number(ohlcv, 1),
            self.safe_number(ohlcv, 2),
            self.safe_number(ohlcv, 3),
            self.safe_number(ohlcv, 4),
            self.safe_number(ohlcv, 6),
        ]

    async def watch_order_book(self, symbol, limit=None, params={}):
        channel = 'depth'
        await self.load_markets()
        market = self.market(symbol)
        messageHash = channel + ':' + market['id']
        orderbook = await self.watch_public(messageHash, messageHash, params)
        return orderbook.limit(limit)

    def handle_order_book(self, client, message):
        #
        # we get always the full snapshot
        #
        # {
        #     "table":"depth",
        #     "data":[
        #        {
        #           "instrumentId":"BTC-USD-SWAP-LIN",
        #           "seqNum":"1650424356029712528",
        #           "asks":[
        #              [29878,0.303,0,0],
        #              [29880,0.004,0,0],
        #           ],
        #           "checksum":-1222631948,
        #           "bids":[
        #              [29877, 0.047, 0, 0],
        #              [29872, 0.001, 0, 0],
        #           ],
        #           "timestamp":"1652708448921"
        #        }
        #     ],
        #     "action":"partial"
        #  }
        #
        channel = self.safe_string(message, 'table')
        data = self.safe_value(message, 'data', [])
        for i in range(0, len(data)):
            entry = data[i]
            marketId = self.safe_string(entry, 'instrumentId')
            market = self.safe_market(marketId)
            symbol = market['symbol']
            timestamp = self.safe_integer(entry, 'timestamp')
            snapshot = self.parse_order_book(entry, symbol, timestamp)
            orderbook = None
            if not (symbol in self.orderbooks):
                orderbook = self.order_book(snapshot)
                self.orderbooks[symbol] = orderbook
            else:
                orderbook = self.orderbooks[symbol]
                orderbook.reset(snapshot)
            messageHash = channel + ':' + marketId
            client.resolve(orderbook, messageHash)

    async def watch_trades(self, symbol, since=None, limit=None, params={}):
        channel = 'trade'
        await self.load_markets()
        market = self.market(symbol)
        symbol = market['symbol']
        messageHash = channel + ':' + market['id']
        trades = await self.watch_public(messageHash, messageHash, params)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_since_limit(trades, since, limit, 'timestamp', True)

    def handle_trades(self, client, message):
        #
        #    {
        #        table: 'trade',
        #        data: [
        #          {
        #            side: 'BUY',
        #            quantity: '0.042',
        #            price: '30081.0',
        #            marketCode: 'BTC-USD-SWAP-LIN',
        #            tradeId: '304734619689878207',
        #            timestamp: '1652698566797'
        #          }
        #        ]
        #    }
        #
        topic = self.safe_string(message, 'table')
        data = self.safe_value(message, 'data', [])
        tradesLimit = self.safe_integer(self.options, 'tradesLimit', 1000)
        marketIds = {}
        for i in range(0, len(data)):
            trade = data[i]
            marketId = self.safe_string(trade, 'marketCode')
            marketIds[marketId] = True
            market = self.safe_market(marketId, None)
            symbol = market['symbol']
            parsedTrade = self.parse_ws_trade(trade, market)
            stored = self.safe_value(self.trades, symbol)
            if stored is None:
                stored = ArrayCache(tradesLimit)
                self.trades[symbol] = stored
            stored.append(parsedTrade)
        marketIdsArray = list(marketIds.keys())
        for i in range(0, len(marketIdsArray)):
            marketId = marketIdsArray[i]
            messageHash = topic + ':' + marketId
            market = self.safe_market(marketId)
            symbol = market['symbol']
            stored = self.safe_value(self.trades, symbol)
            client.resolve(stored, messageHash)

    def parse_ws_trade(self, trade, market=None):
        #
        #   {
        #       side: 'BUY',
        #       quantity: '0.042',
        #       price: '30081.0',
        #       marketCode: 'BTC-USD-SWAP-LIN',
        #       tradeId: '304734619689878207',
        #       timestamp: '1652698566797'
        #   }
        #
        marketId = self.safe_string(trade, 'marketCode')
        market = self.safe_market(marketId, market)
        id = self.safe_string(trade, 'tradeId')
        timestamp = self.safe_integer(trade, 'timestamp')
        side = self.safe_string_lower(trade, 'side')
        amount = self.safe_string(trade, 'quantity')
        price = self.safe_string(trade, 'price')
        return self.safe_trade({
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'order': None,
            'type': None,
            'takerOrMaker': None,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': None,
            'fee': None,
            'info': trade,
        }, market)

    async def watch_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        messageHash = 'order'
        market = None
        if symbol is not None:
            market = self.market(symbol)
            symbol = market['symbol']
            messageHash += ':' + market['id']
        else:
            messageHash += ':all'
        orders = await self.watch_private(messageHash, messageHash, params)
        if self.newUpdates:
            limit = orders.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit, True)

    def handle_order(self, client, message, subscription=None):
        #
        #
        #    {
        #        table: 'order',
        #        data: [
        #          {
        #            accountId: '39422',
        #            clientOrderId: '1652712518830',
        #            orderId: '1002215627250',
        #            price: '40.0',
        #            quantity: '0.01',
        #            side: 'BUY',
        #            status: 'CANCELED_BY_USER',
        #            marketCode: 'LTC-USD',
        #            timeInForce: 'GTC',
        #            timestamp: '1652712536469',
        #            remainQuantity: '0.01',
        #            notice: 'OrderClosed',
        #            orderType: 'LIMIT',
        #            isTriggered: 'false'
        #          }
        #        ]
        #    }
        #
        #    {
        #      table: 'order',
        #      data: [
        #        {
        #          accountId: '39422',
        #          clientOrderId: '1652713431643',
        #          orderId: '1002215706472',
        #          quantity: '0.001',
        #          side: 'SELL',
        #          status: 'FILLED',
        #          marketCode: 'BTC-USD-SWAP-LIN',
        #          timestamp: '1652713431854',
        #          matchId: '304734619690202846',  # trade field
        #          matchPrice: '29480.0',  # trade field
        #          matchQuantity: '0.001',  # trade field
        #          orderMatchType: 'TAKER',  # trade field
        #          remainQuantity: '0.0',
        #          notice: 'OrderMatched',
        #          orderType: 'MARKET',
        #          fees: '0.02358400',
        #          feeInstrumentId: 'USD',
        #          isTriggered: 'false'
        #        }
        #      ]
        #    }
        #
        channel = self.safe_string(message, 'table')
        rawOrders = self.safe_value(message, 'data', [])
        if self.orders is None:
            limit = self.safe_integer(self.options, 'ordersLimit', 1000)
            self.orders = ArrayCacheBySymbolById(limit)
        stored = self.orders
        marketIds = {}
        for i in range(0, len(rawOrders)):
            order = rawOrders[i]
            notice = self.safe_string(order, 'notice')
            if notice == 'OrderMatched':
                # self means that the order has the trade info built in so
                # it's a order + trade update combined
                tradeObject = {
                    'matchId': self.safe_string(order, 'matchId'),
                    'matchPrice': self.safe_string(order, 'matchPrice'),
                    'matchQuantity': self.safe_string(order, 'matchQuantity'),
                    'orderMatchType': self.safe_string(order, 'orderMatchType'),
                    'matchTimestamp': self.safe_string(order, 'timestamp'),
                    'orderType': self.safe_string(order, 'orderType'),
                    'fees': self.safe_string(order, 'fees'),
                    'feeInstrumentId': self.safe_string(order, 'feeInstrumentId'),
                    'side': self.safe_string(order, 'side'),
                    'orderId': self.safe_string(order, 'orderId'),
                    'marketCode': self.safe_string(order, 'marketCode'),
                }
                # we don't use the own order object itself(order['matchIds'] = order)
                # because would cause a circular import error in json later on
                order['matchIds'] = [tradeObject]
                self.handle_my_trade(client, tradeObject)
            parsed = self.parse_order(order)
            stored.append(parsed)
            symbol = parsed['symbol']
            market = self.market(symbol)
            marketId = market['id']
            marketIds[marketId] = True
        # non-symbol specific
        messageHash = channel + ':all'
        client.resolve(self.orders, messageHash)
        keys = list(marketIds.keys())
        for i in range(0, len(keys)):
            marketId = keys[i]
            messageHash = channel + ':' + marketId
            client.resolve(self.orders, messageHash)

    def handle_my_trade(self, client, message):
        #
        #  {
        #          accountId: '39422',
        #          orderId: '1002215706472',
        #          side: 'SELL',
        #          marketCode: 'BTC-USD-SWAP-LIN',
        #          matchTimestamp: '1652713431854',
        #          matchId: '304734619690202846',
        #          matchPrice: '29480.0',
        #          matchQuantity: '0.001',
        #          orderMatchType: 'TAKER',
        #          orderType: 'MARKET',
        #          fees: '0.02358400',
        #          feeInstrumentId: 'USD',
        #   }
        #
        marketId = self.safe_string(message, 'marketCode')
        market = self.safe_market(marketId, None)
        trades = self.myTrades
        if trades is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            trades = ArrayCacheBySymbolById(limit)
        parsed = self.parse_trade(message, market)
        # add missing field
        parsed['type'] = self.safe_string_lower(message, 'orderType')
        trades.append(parsed)
        channel = 'usertrade'
        messageHash = channel + ':' + market['id']
        client.resolve(trades, messageHash)
        genericHash = channel + ':all'
        client.resolve(trades, genericHash)

    async def watch_balance(self, params={}):
        messageHash = 'balance:all'
        return await self.watch_private(messageHash, messageHash, params)

    def handle_balance(self, client, message):
        #
        #    {
        #        table: 'balance',
        #        accountId: '39422',
        #        timestamp: '1652710563235',
        #        tradeType: 'LINEAR',
        #        data: [
        #          {
        #            total: '47.7114057900',
        #            reserved: '6.00',
        #            instrumentId: 'USD',
        #            available: '41.7114057900',
        #            quantityLastUpdated: '1652188203911'
        #          },
        #          {
        #            total: '0.98',
        #            reserved: '0',
        #            instrumentId: 'DOGE',
        #            available: '0.98',
        #            quantityLastUpdated: '1651655519741'
        #          }
        #        ]
        #    }
        #
        channel = self.safe_string(message, 'table')
        data = self.safe_value(message, 'data', [])
        for i in range(0, len(data)):
            balance = data[i]
            currencyId = self.safe_string(balance, 'instrumentId')
            code = self.safe_currency_code(currencyId)
            account = self.balance[code] if (code in self.balance) else self.account()
            account['total'] = self.safe_string(balance, 'total')
            account['free'] = self.safe_string(balance, 'available')
            account['used'] = self.safe_string(balance, 'reserved')
            self.balance[code] = account
        self.balance = self.safe_balance(self.balance)
        messageHash = channel + ':all'
        client.resolve(self.balance, messageHash)

    async def watch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        subscriptionHash = 'order'
        messageHash = 'usertrade'
        market = None
        if symbol is not None:
            market = self.market(symbol)
            symbol = market['symbol']
            subscriptionHash += ':' + market['id']
            messageHash += ':' + market['id']
        else:
            subscriptionHash += ':all'
            messageHash += ':all'
        trades = await self.watch_private(subscriptionHash, messageHash, params)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(trades, symbol, since, limit, True)

    async def watch_public(self, subscriptionHash, messageHash, params={}):
        url = self.urls['api']['ws']
        id = self.nonce()
        request = {
            'op': 'subscribe',
            'tag': id,
            'args': [subscriptionHash],
        }
        message = self.extend(request, params)
        return await self.watch(url, messageHash, message, subscriptionHash)

    async def watch_private(self, subscriptionHash, messageHash, params={}):
        await self.authenticate()
        return await self.watch_public(subscriptionHash, messageHash, params)

    async def authenticate(self, params={}):
        self.check_required_credentials()
        url = self.urls['api']['ws']
        messageHash = 'login'
        client = self.client(url)
        future = self.safe_value(client.subscriptions, messageHash)
        if future is None:
            future = client.future('authenticated')
            timestamp = str(self.milliseconds())
            method = 'GET'
            path = '/auth/self/verify'
            auth = timestamp + method + path
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'base64')
            request = {
                'op': messageHash,
                'data': {
                    'apiKey': self.apiKey,
                    'timestamp': timestamp,
                    'signature': signature,
                },
            }
            self.spawn(self.watch, url, messageHash, request, messageHash, future)
        return await future

    def handle_error_message(self, client, message):
        #
        #    {
        #        event: 'login',
        #        success: False,
        #        message: 'Signature is invalid',
        #        code: '20000',
        #        timestamp: '1652709878447'
        #    }
        #
        #    {
        #        event: 'placeorder',
        #        submitted: False,
        #        tag: '1652714023869',
        #        message: 'FAILED sanity bound check as price(14000) >  upper bound(13260)',
        #        code: '710003',
        #        timestamp: '1652714024078',
        #        data: {
        #          clientOrderId: '1652714023869',
        #          marketCode: 'BTC-USD-SWAP-LIN',
        #          side: 'BUY',
        #          orderType: 'STOP_LIMIT',
        #          quantity: '0.001',
        #          timeInForce: 'GTC',
        #          limitPrice: '14000',
        #          stopPrice: '13000',
        #          source: 0
        #        }
        #     }
        #
        success = self.safe_value(message, 'success')
        try:
            if not success:
                error = self.safe_string(message, 'code')
                feedback = self.id + ' ' + self.json(message)
                self.throw_exactly_matched_exception(self.exceptions['ws']['exact'], error, feedback)
        except Exception as e:
            if isinstance(e, AuthenticationError):
                client.reject(e, 'authenticated')
                method = 'login'
                if method in client.subscriptions:
                    del client.subscriptions[method]
                return False
        return message

    def handle_message(self, client, message):
        #
        #   {event: 'Welcome', nonce: '253ae705', timestamp: '1652711966653'}
        #
        #   {
        #      success: True,
        #      tag: '1652712019244',
        #      event: 'subscribe',
        #      channel: 'trade:BTC-USD',
        #      timestamp: '1652712020624'
        #   }
        #
        #   {
        #       event: 'placeorder',
        #       submitted: True,
        #       tag: '1652714101465',
        #       timestamp: '1652714101676',
        #       data: {
        #         clientOrderId: '1652714101465',
        #         marketCode: 'BTC-USD-SWAP-LIN',
        #         side: 'BUY',
        #         orderType: 'STOP_LIMIT',
        #         quantity: '0.001',
        #         timeInForce: 'GTC',
        #         limitPrice: '15300',
        #         stopPrice: '15000',
        #         orderId: '1002215765848',
        #         source: 0
        #       }
        #   }
        #
        if not self.handle_error_message(client, message):
            return
        event = self.safe_string(message, 'event')
        if event == 'login':
            self.handle_authenticate(client, message)
            return
        tables = {
            'ticker': self.handle_ticker,
            'trade': self.handle_trades,
            'depth': self.handle_order_book,
            'order': self.handle_order,
            'balance': self.handle_balance,
        }
        topic = self.safe_string(message, 'table')
        # specific check because self topic has the timeframe attached
        # so we would need to list all possibilities in the methods object
        if topic is not None and topic.find('candles') >= 0:
            self.handle_ohlcv(client, message)
            return
        method = self.safe_value(tables, topic)
        if method is not None:
            method(client, message)

    def handle_authenticate(self, client, message):
        #
        #  {event: 'login', success: True, timestamp: '1652710009321'}
        #
        client.resolve(message, 'authenticated')
        return message

    def handle_pong(self, client, message):
        client.lastPong = self.milliseconds()
        return message

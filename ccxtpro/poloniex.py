# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support as ccxt


class poloniex(ccxt.poloniex):

    def describe(self):
        return self.deep_extend(super(poloniex, self).describe(), {
            'has': {
                'fetchWsTicker': True,
                'fetchWsOrderBook': True,
            },
            'urls': {
                'api': {
                    'ws': 'wss://api2.poloniex.com/',
                },
            },
        })

    def get_ws_message_hash(self, client, response):
        channelId = str(response[0])
        length = len(response)
        if length <= 2:
            return
        if channelId == '1002':
            return channelId + str(response[2][0])
        else:
            return channelId

    def handle_ws_ticker(self, response):
        data = response[2]
        market = self.safe_value(self.options['marketsByNumericId'], str(data[0]))
        symbol = self.safe_string(market, 'symbol')
        return {
            'info': response,
            'symbol': symbol,
            'last': float(data[1]),
            'ask': float(data[2]),
            'bid': float(data[3]),
            'change': float(data[4]),
            'baseVolume': float(data[5]),
            'quoteVolume': float(data[6]),
            'active': False if data[7] else True,
            'high': float(data[8]),
            'low': float(data[9]),
        }

    async def fetch_ws_ticker(self, symbol):
        await self.load_markets()
        market = self.market(symbol)
        numericId = str(market['info']['id'])
        url = self.urls['api']['websocket']['public']
        return await self.WsTickerMessage(url, '1002' + numericId, {
            'command': 'subscribe',
            'channel': 1002,
        })

    async def load_markets(self, reload=False, params={}):
        markets = await super(poloniex, self).load_markets(reload, params)
        marketsByNumericId = self.safe_value(self.options, 'marketsByNumericId')
        if (marketsByNumericId is None) or reload:
            marketsByNumericId = {}
            for i in range(0, len(self.symbols)):
                symbol = self.symbols[i]
                market = self.markets[symbol]
                numericId = self.safe_string(market, 'numericId')
                marketsByNumericId[numericId] = market
            self.options['marketsByNumericId'] = marketsByNumericId
        return markets

    async def fetch_ws_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        numericId = self.safe_string(market, 'numericId')
        url = self.urls['api']['ws']
        orderbook = await self.sendWsMessage(self.handleWsOrderBook, url, numericId, {
            'command': 'subscribe',
            'channel': numericId,
        })
        return orderbook.limit(limit)
        #  # add limit method
        # return self.extend(orderbook, {
        #     'bids': orderbook['bids'][0:limit],
        #     'asks': orderbook['asks'][0:limit],
        # })
        # return await self.WsOrderBookMessage(url, numericId, {
        #     'command': 'subscribe',
        #     'channel': numericId,
        # })

    def handle_ws_order_book(self, message):
        #
        # first response
        #
        #     [
        #         14,  # channelId == market['numericId']
        #         8767,  # nonce
        #         [
        #             [
        #                 "i",  # initial snapshot
        #                 {
        #                     "currencyPair": "BTC_BTS",
        #                     "orderBook": [
        #                         { # asks
        #                             "0.00001853": "2537.5637",  # price, size
        #                             "0.00001854": "1567238.172367"
        #                         },
        #                         { # bids
        #                             "0.00001841": "3645.3647",
        #                             "0.00001840": "1637.3647"
        #                         }
        #                     ]
        #                 }
        #             ]
        #         ]
        #     ]
        #
        # subsequent updates
        #
        #     [
        #         14,
        #         8768,
        #         [
        #             ["o", 1, "0.00001823", "5534.6474"],  # orderbook delta, bids, price, size
        #             ["o", 0, "0.00001824", "6575.464"],  # orderbook delta, asks, price, size
        #             ["t", "42706057", 1, "0.05567134", "0.00181421", 1522877119]  # trade, id, sell, price, size, timestamp
        #         ]
        #     ]
        #
        # TODO: handle incremental trades too
        # print('were here again', orderbook)
        # sys.exit()
        marketId = str(message[0])
        nonce = message[1]
        data = message[2]
        market = self.safe_value(self.options['marketsByNumericId'], marketId)
        symbol = self.safe_string(market, 'symbol')
        deltas = []
        for i in range(0, len(data)):
            delta = data[i]
            if delta[0] == 'i':
                snapshot = self.safe_value(delta[1], 'orderBook', [])
                sides = ['asks', 'bids']
                orderbook = self.orderbook(symbol)
                for j in range(0, len(snapshot)):
                    orders = snapshot[j]
                    side = sides[j]
                    prices = list(orders.keys())
                    bookside = orderbook[side]
                    for k in range(0, len(prices)):
                        price = prices[k]
                        amount = float(orders[price])
                        bookside.store(price, amount)
                    bookside.reset(bookside.index)
                orderbook['nonce'] = nonce
                return orderbook
                print(orderbook)
                sys.exit()
                # asks = snapshot[0]
                # bids = snapshot[1]
                # prices = list(asks.keys())
                # for j in range(0, len(prices)):
                #     price = prices[i]
                #     amount = float(asks[price])
                #     orderbook['asks'].store([price, amount])
                # }
                # for j in range(0, len(asks)):
                #     orderbook.asks.store()
                # }
                # self.orderbooks[symbol] = IncrementalOrderBook({
                #     'bids': self.parse_bid_ask(bids),
                #     'asks': self.parse_bid_ask(asks),
                #     'nonce': nonce,
                #     'timestamp': None,
                #     'datetime': None,
                # })
            elif delta[0] == 'o':
                price = float(delta[2])
                amount = float(delta[3])
                operation = 'delete' if (amount == 0) else 'add'
                side = 'bids' if delta[1] else 'asks'
                delta = [None, operation, side, price, amount]
                deltas.append(delta)
        # if not (symbol in list(self.orderBooks.keys())):
        #
        # }
        # incrementalBook = self.orderBooks[symbol]
        # incrementalBook.update(deltas)
        # incrementalBook.orderBook['nonce'] = orderbook[1]
        # return incrementalBook.orderBook

    def parse_bid_ask(self, bidasks):
        prices = list(bidasks.keys())
        result = []
        for i in range(0, len(prices)):
            price = prices[i]
            amount = bidasks[price]
            result.append([float(price), float(amount)])
        return result

    def handle_ws_dropped(self, client, message, messageHash):
        print('??')
        if messageHash is not None and int(messageHash) < 1000:
            self.handle_ws_order_book(message)

# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxtpro
import ccxt.async_support as ccxt
import math
from ccxt.base.errors import ExchangeError


class gateio(ccxtpro.Exchange, ccxt.gateio):

    def describe(self):
        return self.deep_extend(super(gateio, self).describe(), {
            'has': {
                'watchOrderBook': True,
                'watchTicker': True,
                'watchTrades': True,
                'watchOHLCV': True,
            },
            'urls': {
                'api': {
                    'ws': 'wss://ws.gate.io/v3',
                },
            },
        })

    async def watch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        marketId = market['id'].upper()
        requestId = self.nonce()
        url = self.urls['api']['ws']
        if not limit:
            limit = 30
        elif limit != 1 and limit != 5 and limit != 10 and limit != 20 and limit != 30:
            raise ExchangeError(self.id + ' watchOrderBook limit argument must be None, 1, 5, 10, 20, or 30')
        interval = self.safe_string(params, 'interval', '0.00000001')
        precision = -1 * math.log10(interval)
        if precision < 0 or precision > 8 or precision % 1 != 0:
            raise ExchangeError(self.id + ' invalid interval')
        messageHash = 'depth.update' + ':' + marketId
        subscribeMessage = {
            'id': requestId,
            'method': 'depth.subscribe',
            'params': [marketId, limit, interval],
        }
        future = self.watch(url, messageHash, subscribeMessage)
        return future

    def sign_message(self, client, messageHash, message, params={}):
        # todo: implement gateio signMessage
        return message

    def limit_order_book(self, orderbook, symbol, limit=None, params={}):
        return orderbook.limit(limit)

    def handle_order_book(self, client, message):
        params = message['params']
        clean = params[0]
        book = params[1]
        marketId = params[2]
        methodType = message['method']
        messageHash = methodType + ':' + marketId
        orderBook = None
        if clean:
            orderBook = self.order_book({})
            self.orderbooks[marketId] = orderBook
        else:
            orderBook = self.orderbooks[marketId]
        sides = ['bids', 'asks']
        for j in range(0, 2):
            side = sides[j]
            if side in book:
                bookSide = book[side]
                for i in range(0, len(bookSide)):
                    order = bookSide[i]
                    orderBook[side].store(float(order[0]), float(order[1]))
        client.resolve(orderBook, messageHash)

    async def watch_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        marketId = market['id'].upper()
        requestId = self.nonce()
        url = self.urls['api']['ws']
        subscribeMessage = {
            'id': requestId,
            'method': 'ticker.subscribe',
            'params': [marketId],
        }
        messageHash = 'ticker.update' + ':' + marketId
        return await self.watch(url, messageHash, subscribeMessage)

    def handle_ticker(self, client, message):
        result = message['params']
        marketId = result[0]
        normalMarketId = marketId.lower()
        market = None
        if normalMarketId in self.markets_by_id:
            market = self.markets_by_id[normalMarketId]
        ticker = result[1]
        parsed = self.parse_ticker(ticker, market)
        methodType = message['method']
        messageHash = methodType + ':' + marketId
        client.resolve(parsed, messageHash)

    async def watch_trades(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        marketId = market['id'].upper()
        requestId = self.nonce()
        url = self.urls['api']['ws']
        subscribeMessage = {
            'id': requestId,
            'method': 'trades.subscribe',
            'params': [marketId],
        }
        messageHash = 'trades.update' + ':' + marketId
        return await self.watch(url, messageHash, subscribeMessage)

    def handle_trades(self, client, messsage):
        result = messsage['params']
        marketId = result[0]
        normalMarketId = marketId.lower()
        market = None
        if normalMarketId in self.markets_by_id:
            market = self.markets_by_id[normalMarketId]
        trades = result[1]
        for i in range(0, len(trades)):
            trade = trades[i]
            parsed = self.parse_trade(trade, market)
            self.trades[marketId].append(parsed)
        methodType = messsage['method']
        messageHash = methodType + ':' + marketId
        client.resolve(self.trades[marketId], messageHash)

    async def watch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        marketId = market['id'].upper()
        requestId = self.nonce()
        url = self.urls['api']['ws']
        interval = int(self.timeframes[timeframe])
        subscribeMessage = {
            'id': requestId,
            'method': 'kline.subscribe',
            'params': [marketId, interval],
        }
        messageHash = 'kline.update' + ':' + marketId
        return await self.watch(url, messageHash, subscribeMessage)

    def handle_ohlcv(self, client, message):
        ohlcv = message['params'][0]
        marketId = ohlcv[7]
        normalMarketId = marketId.lower()
        market = None
        if normalMarketId in self.markets_by_id:
            market = self.markets_by_id[normalMarketId]
        parsed = self.parse_ohlcv(ohlcv, market)
        methodType = message['method']
        messageHash = methodType + ':' + marketId
        client.resolve(parsed, messageHash)

    def handle_message(self, client, message):
        methods = {
            'depth.update': self.handle_order_book,
            'ticker.update': self.handle_ticker,
            'trades.update': self.handle_trades,
            'kline.update': self.handle_ohlcv,
        }
        methodType = self.safe_string(message, 'method')
        method = self.safe_value(methods, methodType)
        if method:
            method(client, message)

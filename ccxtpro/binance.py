# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxtpro
import ccxt.async_support as ccxt
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import NotSupported


class binance(ccxtpro.Exchange, ccxt.binance):

    def describe(self):
        return self.deep_extend(super(binance, self).describe(), {
            'has': {
                'watchOrderBook': True,
                'watchOHLCV': True,
                'watchTrades': True,
            },
            'urls': {
                'api': {
                    'ws': 'wss://stream.binance.com:9443/ws',
                    # 'ws': 'wss://echo.websocket.org/',
                    # 'ws': 'ws://127.0.0.1:8080',
                },
            },
            'options': {
                'marketsByLowerCaseId': {},
            },
        })

    async def load_markets(self, reload=False, params={}):
        markets = await super(binance, self).load_markets(reload, params)
        marketsByLowercaseId = self.safe_value(self.options, 'marketsByLowercaseId')
        if (marketsByLowercaseId is None) or reload:
            marketsByLowercaseId = {}
            for i in range(0, len(self.symbols)):
                symbol = self.symbols[i]
                lowercaseId = self.markets[symbol]['id'].lower()
                self.markets[symbol]['lowercaseId'] = lowercaseId
                marketsByLowercaseId[lowercaseId] = self.markets[symbol]
            self.options['marketsByLowercaseId'] = marketsByLowercaseId
        return markets

    async def watch_trades(self, symbol):
        #     await self.load_markets()
        #     market = self.market(symbol)
        #     url = self.urls['api']['ws'] + market['id'].lower() + '@trade'
        #     return await self.WsTradesMessage(url, url)
        raise NotSupported(self.id + ' watchTrades not implemented yet')

    def handle_trades(self, response):
        #     parsed = self.parse_trade(response)
        #     parsed['symbol'] = self.parseSymbol(response)
        #     return parsed
        raise NotSupported(self.id + ' handleTrades not implemented yet')

    async def watch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        #     await self.load_markets()
        #     interval = self.timeframes[timeframe]
        #     market = self.market(symbol)
        #     url = self.urls['api']['ws'] + market['id'].lower() + '@kline_' + interval
        #     return await self.WsOHLCVMessage(url, url)
        raise NotSupported(self.id + ' watchOHLCV not implemented yet')

    def handle_ohlcv(self, ohlcv):
        #     data = ohlcv['k']
        #     timestamp = self.safe_integer(data, 'T')
        #     open = self.safe_float(data, 'o')
        #     high = self.safe_float(data, 'h')
        #     close = self.safe_float(data, 'l')
        #     low = self.safe_float(data, 'c')
        #     volume = self.safe_float(data, 'v')
        #     return [timestamp, open, high, close, low, volume]
        raise NotSupported(self.id + ' handleOHLCV not implemented yet ' + self.json(ohlcv))

    async def watch_order_book(self, symbol, limit=None, params={}):
        # for 1000ms: <symbol>@depth<levels>
        # OR
        # for 100ms: <symbol>@depth<levels>@100ms
        # valid <levels> are 5, 10, or 20
        if limit is not None:
            if (limit != 25) and (limit != 100):
                raise ExchangeError(self.id + ' watchOrderBook limit argument must be None, 5, 10 or 20')
        await self.load_markets()
        market = self.market(symbol)
        # self should be executed much later
        # orderbook = await self.fetch_order_book(symbol, limit, params)
        # request = {}
        name = 'depth'
        messageHash = market['lowercaseId'] + '@' + name
        url = self.urls['api']['ws']  # + '/' + messageHash
        requestId = self.nonce()
        request = {
            'method': 'SUBSCRIBE',
            'params': [
                messageHash,
            ],
            'id': requestId,
        }
        return await self.watch(url, messageHash, self.extend(request, params), messageHash)
        # self.onetwo = future
        # client = self.clients[url]
        # client['futures'][requestId] = future
        # return await future  # self.watch(url, messageHash, self.extend(request, params), messageHash)
        # raise NotSupported(self.id + ' watchOrderBook not implemented yet')
        # return future

    async def fetch_order_book_snapshot(self, symbol):
        # todo: self is sync in php - make it async
        snapshot = await self.fetch_order_book(symbol)
        orderbook = self.orderbooks[symbol]
        orderbook.update(snapshot)
        # asks = orderbook['asks']
        # for i in range(0, len(snapshot['asks'])):
        #     asks.storeArray(snapshot['asks'][i])
        # }
        # bids = orderbook['bids']
        # for i in range(0, len(snapshot['bids'])):
        #     bids.storeArray(snapshot['bids'][i])
        # }

    def handle_order_book(self, client, message):
        #
        #     {
        #         "e": "depthUpdate",  # Event type
        #         "E": 123456789,  # Event time
        #         "s": "BNBBTC",  # Symbol
        #         "U": 157,  # First update ID in event
        #         "u": 160,  # Final update ID in event
        #         "b": [ # bids
        #             ["0.0024", "10"],  # price, size
        #         ],
        #         "a": [ # asks
        #             ["0.0026", "100"],  # price, size
        #         ]
        #     }
        #
        marketId = self.safe_string(message, 's')
        market = None
        symbol = None
        if marketId is not None:
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
                symbol = market['symbol']
        name = 'depth'
        messageHash = market['lowercaseId'] + '@' + name
        #
        # initial snapshot is fetched with ccxt's fetchOrderBook
        # the feed does not include a snapshot, just the deltas
        #
        #
        fetching = False
        if not fetching:
            # fetch the snapshot in a separate async call
            # self.spawn(self.fetch_order_book_snapshot, ...)
            raise NotSupported(self.id + ' snapshot fetching is wip')
        if symbol in self.orderbooks:
            orderbook = self.orderbooks[symbol]
            # resolve
            client.resolve(orderbook, messageHash)
        else:
            # accumulate deltas
            self.options['cache'][symbol] = []
            self.options['cache'][messageHash].append(message)
        # orderbook = self.order
        # deltas = []
        # nonce = message['u']
        # for i in range(0, len(message['b'])):
        #     bid = message['b'][i]
        #     deltas.append([nonce, 'absolute', 'bids', float(bid[0]), float(bid[1])])
        # }
        # for i in range(0, len(message['a'])):
        #     asks = message['a'][i]
        #     deltas.append([nonce, 'absolute', 'asks', float(asks[0]), float(asks[1])])
        # }
        # symbol = self.parseSymbol(message)
        # incrementalBook = self.orderbooks[symbol]
        # incrementalBook.update(deltas)
        # timestamp = self.safe_integer(message, 'E')
        # incrementalBook.message['timestamp'] = timestamp
        # incrementalBook.message['datetime'] = self.iso8601(timestamp)
        # incrementalBook.message['nonce'] = message['u']
        # return incrementalBook.orderBook

    def sign_message(self, client, messageHash, message, params={}):
        # todo: binance signMessage not implemented yet
        return message

    def handle_subscription_status(self, client, message):
        #
        #     {
        #         "result": null,
        #         "id": 1574649734450
        #     }
        #
        return message

    def handle_message(self, client, message):
        # requestId = self.safe_string(
        methods = {
            'depthUpdate': self.handle_order_book,
        }
        event = self.safe_string(message, 'e')
        method = self.safe_string(methods, event)
        if method is None:
            requestId = self.safe_string(message, 'id')
            if requestId is not None:
                return self.handle_subscription_status(client, message)
            return message
        else:
            return self.call(method, client, message)
        # print(message)
        # sys.exit()
        #
        # keys = list(client.futures.keys())
        # for i in range(0, len(keys)):
        #     key = keys[i]
        #     client.reject()
        # }
        #
        # --------------------------------------------------------------------
        #
        # print(new Date(), json.dumps(message, null, 4))
        # print('---------------------------------------------------------')
        # if isinstance(message, list):
        #     channelId = str(message[0])
        #     subscriptionStatus = self.safe_value(self.options['subscriptionStatusByChannelId'], channelId, {})
        #     subscription = self.safe_value(subscriptionStatus, 'subscription', {})
        #     name = self.safe_string(subscription, 'name')
        #     methods = {
        #         'book': 'handleOrderBook',
        #         'ohlc': 'handleOHLCV',
        #         'ticker': 'handleTicker',
        #         'trade': 'handleTrades',
        #     }
        #     method = self.safe_string(methods, name)
        #     if method is None:
        #         return message
        #     else:
        #         return getattr(self, method)(client, message)
        #     }
        # else:
        #     if self.handleErrorMessage(client, message):
        #         event = self.safe_string(message, 'event')
        #         methods = {
        #             'heartbeat': 'handleHeartbeat',
        #             'systemStatus': 'handleSystemStatus',
        #             'subscriptionStatus': 'handleSubscriptionStatus',
        #         }
        #         method = self.safe_string(methods, event)
        #         if method is None:
        #             return message
        #         else:
        #             return getattr(self, method)(client, message)
        #         }
        #     }
        # }

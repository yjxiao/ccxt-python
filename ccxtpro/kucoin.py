# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxtpro
import ccxt.async_support as ccxt
from ccxt.base.errors import ExchangeError


class kucoin(ccxtpro.Exchange, ccxt.kucoin):

    def describe(self):
        return self.deep_extend(super(kucoin, self).describe(), {
            'has': {
                'watchOrderBook': True,
            },
            'options': {
                'watchOrderBookRate': 100,  # get updates every 100ms or 1000ms
            },
        })

    async def watch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        #
        # https://docs.kucoin.com/#level-2-market-data
        #
        # 1. After receiving the websocket Level 2 data flow, cache the data.
        # 2. Initiate a REST request to get the snapshot data of Level 2 order book.
        # 3. Playback the cached Level 2 data flow.
        # 4. Apply the new Level 2 data flow to the local snapshot to ensure that
        # the sequence of the new Level 2 update lines up with the sequence of
        # the previous Level 2 data. Discard all the message prior to that
        # sequence, and then playback the change to snapshot.
        # 5. Update the level2 full data based on sequence according to the
        # size. If the price is 0, ignore the messages and update the sequence.
        # If the size=0, update the sequence and remove the price of which the
        # size is 0 out of level 2. For other cases, please update the price.
        #
        tokenResponse = self.safe_value(self.options, 'token')
        if tokenResponse is None:
            throwException = False
            if self.check_required_credentials(throwException):
                tokenResponse = await self.privatePostBulletPrivate()
                #
                #     {
                #         code: "200000",
                #         data: {
                #             instanceServers: [
                #                 {
                #                     pingInterval:  50000,
                #                     endpoint: "wss://push-private.kucoin.com/endpoint",
                #                     protocol: "websocket",
                #                     encrypt: True,
                #                     pingTimeout: 10000
                #                 }
                #             ],
                #             token: "2neAiuYvAU61ZDXANAGAsiL4-iAExhsBXZxftpOeh_55i3Ysy2q2LEsEWU64mdzUOPusi34M_wGoSf7iNyEWJ1UQy47YbpY4zVdzilNP-Bj3iXzrjjGlWtiYB9J6i9GjsxUuhPw3BlrzazF6ghq4Lzf7scStOz3KkxjwpsOBCH4=.WNQmhZQeUKIkh97KYgU0Lg=="
                #         }
                #     }
                #
            else:
                tokenResponse = await self.publicPostBulletPublic()
        data = self.safe_value(tokenResponse, 'data', {})
        instanceServers = self.safe_value(data, 'instanceServers', [])
        firstServer = self.safe_value(instanceServers, 0, {})
        endpoint = self.safe_string(firstServer, 'endpoint')
        token = self.safe_string(data, 'token')
        nonce = self.nonce()
        query = {
            'token': token,
            'connectId': nonce,
            'acceptUserMessage': 'true',
        }
        url = endpoint + '?' + self.urlencode(query)
        topic = '/market/level2'
        messageHash = topic + ':' + market['id']
        subscribe = {
            'id': nonce,
            'type': 'subscribe',
            'topic': messageHash,
            'response': True,
        }
        subscription = {
            'id': str(nonce),
            'symbol': symbol,
            'topic': topic,
            'messageHash': messageHash,
            'method': self.handle_order_book_subscription,
        }
        request = self.extend(subscribe, params)
        future = self.watch(url, messageHash, request, messageHash, subscription)
        return await self.after(future, self.limit_order_book, symbol, limit, params)
        # return await self.watch(url, messageHash, request, messageHash)
        #  # token = await self.publicPostBulletPublic()
        # name = 'book'
        # request = {}
        # if limit is not None:
        #     request['subscription'] = {
        #         'depth': limit,  # default 10, valid options 10, 25, 100, 500, 1000
        #     }
        # }
        # return await self.watchPublic(name, symbol, self.extend(request, params))

    def limit_order_book(self, orderbook, symbol, limit=None, params={}):
        return orderbook.limit(limit)

    async def fetch_order_book_snapshot(self, client, message, subscription):
        symbol = self.safe_string(subscription, 'symbol')
        messageHash = self.safe_string(subscription, 'messageHash')
        # 3. Get a depth snapshot from https://www.binance.com/api/v1/depth?symbol=BNBBTC&limit=1000 .
        # todo: self is a synch blocking call in ccxt.php - make it async
        snapshot = await self.fetch_order_book(symbol)
        orderbook = self.orderbooks[symbol]
        orderbook.reset(snapshot)
        # unroll the accumulated deltas
        messages = orderbook.cache
        for i in range(0, len(messages)):
            message = messages[i]
            self.handle_order_book_message(client, message, orderbook)
        self.orderbooks[symbol] = orderbook
        client.resolve(orderbook, messageHash)

    def handle_delta(self, bookside, delta):
        price = self.safe_float(delta, 0)
        amount = self.safe_float(delta, 1)
        bookside.store(price, amount)

    def handle_deltas(self, bookside, deltas):
        for i in range(0, len(deltas)):
            self.handle_delta(bookside, deltas[i])

    def handle_order_book_message(self, client, message, orderbook):
        u = self.safe_integer_2(message, 'u', 'lastUpdateId')
        # merge accumulated deltas
        # 4. Drop any event where u is <= lastUpdateId in the snapshot.
        if u > orderbook['nonce']:
            U = self.safe_integer(message, 'U')
            # 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1.
            if (U is not None) and ((U - 1) > orderbook['nonce']):
                raise ExchangeError(self.id + ' handleOrderBook received an out-of-order nonce')
            self.handle_deltas(orderbook['asks'], self.safe_value(message, 'a', []))
            self.handle_deltas(orderbook['bids'], self.safe_value(message, 'b', []))
            orderbook['nonce'] = u
            timestamp = self.safe_integer(message, 'E')
            orderbook['timestamp'] = timestamp
            orderbook['datetime'] = self.iso8601(timestamp)
        return orderbook

    def handle_order_book(self, client, message):
        #
        # initial snapshot is fetched with ccxt's fetchOrderBook
        # the feed does not include a snapshot, just the deltas
        #
        #     {
        #         "e": "depthUpdate",  # Event type
        #         "E": 1577554482280,  # Event time
        #         "s": "BNBBTC",  # Symbol
        #         "U": 157,  # First update ID in event
        #         "u": 160,  # Final update ID in event
        #         "b": [ # bids
        #             ["0.0024", "10"],  # price, size
        #         ],
        #         "a": [ # asks
        #             ["0.0026", "100"],  # price, size
        #         ]
        #     }
        #
        marketId = self.safe_string(message, 's')
        market = None
        symbol = None
        if marketId is not None:
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
                symbol = market['symbol']
        name = 'depth'
        messageHash = market['lowercaseId'] + '@' + name
        orderbook = self.orderbooks[symbol]
        if orderbook['nonce'] is not None:
            # 5. The first processed event should have U <= lastUpdateId+1 AND u >= lastUpdateId+1.
            # 6. While listening to the stream, each new event's U should be equal to the previous event's u+1.
            self.handle_order_book_message(client, message, orderbook)
            client.resolve(orderbook, messageHash)
        else:
            # 2. Buffer the events you receive from the stream.
            orderbook.cache.append(message)

    def sign_message(self, client, messageHash, message, params={}):
        # todo: implement kucoin signMessage
        return message

    def handle_order_book_subscription(self, client, message, subscription):
        symbol = self.safe_string(subscription, 'symbol')
        if symbol in self.orderbooks:
            del self.orderbooks[symbol]
        self.orderbooks[symbol] = self.limited_order_book()
        # fetch the snapshot in a separate async call
        self.spawn(self.fetch_order_book_snapshot, client, message, subscription)

    def handle_subscription_status(self, client, message):
        #
        #     {
        #         id: '1578090438322',
        #         type: 'ack'
        #     }
        #
        requestId = self.safe_string(message, 'id')
        subscriptionsByRequestId = self.index_by(client.subscriptions, 'id')
        subscription = self.safe_value(subscriptionsByRequestId, requestId, {})
        method = self.safe_value(subscription, 'method')
        if method is not None:
            self.call(method, client, message, subscription)
        return message

    def handle_system_status(self, client, message):
        #
        # todo: answer the question whether handleSystemStatus should be renamed
        # and unified as handleStatus for any usage pattern that
        # involves system status and maintenance updates
        #
        #     {
        #         id: '1578090234088',  # connectId
        #         type: 'welcome',
        #     }
        #
        print(message)
        return message

    def handle_subject(self, client, message):
        #
        #     {
        #         "type":"message",
        #         "topic":"/market/level2:BTC-USDT",
        #         "subject":"trade.l2update",
        #         "data":{
        #             "sequenceStart":1545896669105,
        #             "sequenceEnd":1545896669106,
        #             "symbol":"BTC-USDT",
        #             "changes": {
        #                 "asks": [["6","1","1545896669105"]],  # price, size, sequence
        #                 "bids": [["4","1","1545896669106"]]
        #             }
        #         }
        #     }
        #
        subject = self.safe_string(message, 'subject')
        methods = {
            'trade.l2update': self.handle_order_book,
        }
        method = self.safe_value(methods, subject)
        if method is None:
            return message
        else:
            return self.call(method, client, message)

    def handle_error_message(self, client, message):
        return message

    def handle_message(self, client, message):
        if self.handle_error_message(client, message):
            type = self.safe_string(message, 'type')
            methods = {
                # 'heartbeat': self.handleHeartbeat,
                'welcome': self.handle_system_status,
                'ack': self.handle_subscription_status,
                'message': self.handle_subject,
            }
            method = self.safe_value(methods, type)
            if method is None:
                return message
            else:
                return self.call(method, client, message)

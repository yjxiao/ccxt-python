# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxtpro.base.exchange import Exchange
import ccxt.async_support as ccxt
from ccxtpro.base.cache import ArrayCache, ArrayCacheBySymbolById
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol


class hollaex(Exchange, ccxt.hollaex):

    def describe(self):
        return self.deep_extend(super(hollaex, self).describe(), {
            'has': {
                'ws': True,
                'watchBalance': True,
                'watchMyTrades': False,
                'watchOHLCV': False,
                'watchOrderBook': True,
                'watchOrders': True,
                'watchTicker': False,
                'watchTickers': False,  # for now
                'watchTrades': True,
            },
            'urls': {
                'api': {
                    'ws': 'wss://api.hollaex.com/stream',
                },
                'test': {
                    'ws': 'wss://api.sandbox.hollaex.com/stream',
                },
            },
            'options': {
                'watchBalance': {
                    # 'api-expires': None,
                },
                'watchOrders': {
                    # 'api-expires': None,
                },
            },
            'streaming': {
                'ping': self.ping,
            },
            'exceptions': {
                'ws': {
                    'exact': {
                        'Bearer or HMAC authentication required': BadSymbol,  # {error: 'Bearer or HMAC authentication required'}
                        'Error: wrong input': BadRequest,  # {error: 'Error: wrong input'}
                    },
                },
            },
        })

    async def watch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        messageHash = 'orderbook' + ':' + market['id']
        orderbook = await self.watch_public(messageHash, params)
        return orderbook.limit(limit)

    def handle_order_book(self, client, message):
        #
        #     {
        #         "topic":"orderbook",
        #         "action":"partial",
        #         "symbol":"ltc-usdt",
        #         "data":{
        #             "bids":[
        #                 [104.29, 5.2264],
        #                 [103.86,1.3629],
        #                 [101.82,0.5942]
        #             ],
        #             "asks":[
        #                 [104.81,9.5531],
        #                 [105.54,0.6416],
        #                 [106.18,1.4141],
        #             ],
        #             "timestamp":"2022-04-12T08:17:05.932Z"
        #         },
        #         "time":1649751425
        #     }
        #
        marketId = self.safe_string(message, 'symbol')
        channel = self.safe_string(message, 'topic')
        market = self.safe_market(marketId)
        symbol = market['symbol']
        data = self.safe_value(message, 'data')
        timestamp = self.safe_string(data, 'timestamp')
        timestamp = self.parse8601(timestamp)
        snapshot = self.parse_order_book(data, symbol, timestamp)
        orderbook = None
        if not (symbol in self.orderbooks):
            orderbook = self.order_book(snapshot)
            self.orderbooks[symbol] = orderbook
        else:
            orderbook = self.orderbooks[symbol]
            orderbook.reset(snapshot)
        messageHash = channel + ':' + marketId
        client.resolve(orderbook, messageHash)

    async def watch_trades(self, symbol, since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        symbol = market['symbol']
        messageHash = 'trade' + ':' + market['id']
        trades = await self.watch_public(messageHash, params)
        if self.newUpdates:
            limit = trades.getLimit(symbol, limit)
        return self.filter_by_since_limit(trades, since, limit, 'timestamp', True)

    def handle_trades(self, client, message):
        #
        #     {
        #         topic: 'trade',
        #         action: 'partial',
        #         symbol: 'btc-usdt',
        #         data: [
        #             {
        #                 size: 0.05145,
        #                 price: 41977.9,
        #                 side: 'buy',
        #                 timestamp: '2022-04-11T09:40:10.881Z'
        #             },
        #         ]
        #     }
        #
        channel = self.safe_string(message, 'topic')
        marketId = self.safe_string(message, 'symbol')
        market = self.safe_market(marketId)
        symbol = market['symbol']
        stored = self.safe_value(self.trades, symbol)
        if stored is None:
            limit = self.safe_integer(self.options, 'tradesLimit', 1000)
            stored = ArrayCache(limit)
            self.trades[symbol] = stored
        data = self.safe_value(message, 'data', [])
        parsedTrades = self.parse_trades(data, market)
        for j in range(0, len(parsedTrades)):
            stored.append(parsedTrades[j])
        messageHash = channel + ':' + marketId
        client.resolve(stored, messageHash)
        client.resolve(stored, channel)

    async def watch_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        messageHash = 'order'
        market = None
        if symbol is not None:
            market = self.market(symbol)
            symbol = market['symbol']
            messageHash += ':' + market['id']
        orders = await self.watch_private(messageHash, 'watchOrders', params)
        if self.newUpdates:
            limit = orders.getLimit(symbol, limit)
        return self.filter_by_symbol_since_limit(orders, symbol, since, limit, True)

    def handle_order(self, client, message, subscription=None):
        #
        #     {
        #         topic: 'order',
        #         action: 'insert',
        #         user_id: 155328,
        #         symbol: 'ltc-usdt',
        #         data: {
        #             symbol: 'ltc-usdt',
        #             side: 'buy',
        #             size: 0.05,
        #             type: 'market',
        #             price: 0,
        #             fee_structure: {maker: 0.1, taker: 0.1},
        #             fee_coin: 'ltc',
        #             id: 'ce38fd48-b336-400b-812b-60c636454231',
        #             created_by: 155328,
        #             filled: 0.05,
        #             method: 'market',
        #             created_at: '2022-04-11T14:09:00.760Z',
        #             updated_at: '2022-04-11T14:09:00.760Z',
        #             status: 'filled'
        #         },
        #         time: 1649686140
        #     }
        #
        channel = self.safe_string(message, 'topic')
        marketId = self.safe_string(message, 'symbol')
        data = self.safe_value(message, 'data', {})
        # usually the first message is an empty array
        dataLength = len(data)
        if dataLength == 0:
            return 0
        parsed = self.parse_order(data)
        if self.orders is None:
            limit = self.safe_integer(self.options, 'ordersLimit', 1000)
            self.orders = ArrayCacheBySymbolById(limit)
        orders = self.orders
        orders.append(parsed)
        client.resolve(orders)
        # non-symbol specific
        client.resolve(orders, channel)
        messageHash = channel + ':' + marketId
        client.resolve(orders, messageHash)

    async def watch_balance(self, params={}):
        messageHash = 'wallet'
        return await self.watch_private(messageHash, 'watchBalance', params)

    def handle_balance(self, client, message):
        #
        #     {
        #         topic: 'wallet',
        #         action: 'partial',
        #         user_id: 155328,
        #         data: {
        #             eth_balance: 0,
        #             eth_available: 0,
        #             usdt_balance: 18.94344188,
        #             usdt_available: 18.94344188,
        #             ltc_balance: 0.00005,
        #             ltc_available: 0.00005,
        #         },
        #         time: 1649687396
        #     }
        #
        messageHash = self.safe_string(message, 'topic')
        data = self.safe_value(message, 'data')
        keys = list(data.keys())
        for i in range(0, len(keys)):
            key = keys[i]
            parts = key.split('_')
            currencyId = self.safe_string(parts, 0)
            code = self.safe_currency_code(currencyId)
            account = self.balance[code] if (code in self.balance) else self.account()
            second = self.safe_string(parts, 1)
            freeOrTotal = 'free' if (second == 'available') else 'total'
            account[freeOrTotal] = self.safe_string(data, key)
            self.balance[code] = account
        self.balance = self.safe_balance(self.balance)
        client.resolve(self.balance, messageHash)

    async def watch_public(self, messageHash, params={}):
        url = self.urls['api']['ws']
        request = {
            'op': 'subscribe',
            'args': [messageHash],
        }
        message = self.extend(request, params)
        return await self.watch(url, messageHash, message, messageHash)

    async def watch_private(self, messageHash, method, params={}):
        options = self.safe_value(self.options, method, {})
        expires = self.safe_string(options, 'api-expires')
        if expires is None:
            timeout = int(self.timeout / 1000)
            expires = self.sum(self.seconds(), timeout)
            expires = str(expires)
            # we need to memoize these values to avoid generating a new url on each method execution
            # that would trigger a new connection on each received message
            self.options[method]['api-expires'] = expires
        self.check_required_credentials()
        url = self.urls['api']['ws']
        auth = 'CONNECT' + '/stream' + expires
        signature = self.hmac(self.encode(auth), self.encode(self.secret))
        authParams = {
            'api-key': self.apiKey,
            'api-signature': signature,
            'api-expires': expires,
        }
        signedUrl = url + '?' + self.urlencode(authParams)
        request = {
            'op': 'subscribe',
            'args': [messageHash],
        }
        message = self.extend(request, params)
        return await self.watch(signedUrl, messageHash, message, messageHash)

    def handle_error_message(self, client, message):
        #
        #     {error: 'Bearer or HMAC authentication required'}
        #     {error: 'Error: wrong input'}
        #
        error = self.safe_integer(message, 'error')
        try:
            if error is not None:
                feedback = self.id + ' ' + self.json(message)
                self.throw_exactly_matched_exception(self.exceptions['ws']['exact'], error, feedback)
        except Exception as e:
            if isinstance(e, AuthenticationError):
                return False
        return message

    def handle_message(self, client, message):
        #
        # pong
        #
        #     {message: 'pong'}
        #
        # trade
        #
        #     {
        #         topic: 'trade',
        #         action: 'partial',
        #         symbol: 'btc-usdt',
        #         data: [
        #             {
        #                 size: 0.05145,
        #                 price: 41977.9,
        #                 side: 'buy',
        #                 timestamp: '2022-04-11T09:40:10.881Z'
        #             },
        #         ]
        #     }
        #
        # orderbook
        #
        #     {
        #         topic: 'orderbook',
        #         action: 'partial',
        #         symbol: 'ltc-usdt',
        #         data: {
        #             bids: [
        #                 [104.29, 5.2264],
        #                 [103.86,1.3629],
        #                 [101.82,0.5942]
        #             ],
        #             asks: [
        #                 [104.81,9.5531],
        #                 [105.54,0.6416],
        #                 [106.18,1.4141],
        #             ],
        #             timestamp: '2022-04-11T10:37:01.227Z'
        #         },
        #         time: 1649673421
        #     }
        #
        # order
        #
        #     {
        #         topic: 'order',
        #         action: 'insert',
        #         user_id: 155328,
        #         symbol: 'ltc-usdt',
        #         data: {
        #             symbol: 'ltc-usdt',
        #             side: 'buy',
        #             size: 0.05,
        #             type: 'market',
        #             price: 0,
        #             fee_structure: {maker: 0.1, taker: 0.1},
        #             fee_coin: 'ltc',
        #             id: 'ce38fd48-b336-400b-812b-60c636454231',
        #             created_by: 155328,
        #             filled: 0.05,
        #             method: 'market',
        #             created_at: '2022-04-11T14:09:00.760Z',
        #             updated_at: '2022-04-11T14:09:00.760Z',
        #             status: 'filled'
        #         },
        #         time: 1649686140
        #     }
        #
        # balance
        #
        #     {
        #         topic: 'wallet',
        #         action: 'partial',
        #         user_id: 155328,
        #         data: {
        #             eth_balance: 0,
        #             eth_available: 0,
        #             usdt_balance: 18.94344188,
        #             usdt_available: 18.94344188,
        #             ltc_balance: 0.00005,
        #             ltc_available: 0.00005,
        #         }
        #     }
        #
        if not self.handle_error_message(client, message):
            return
        content = self.safe_string(message, 'message')
        if content == 'pong':
            self.handle_pong(client, message)
            return
        methods = {
            'trade': self.handle_trades,
            'orderbook': self.handle_order_book,
            'order': self.handle_order,
            'wallet': self.handle_balance,
        }
        topic = self.safe_value(message, 'topic')
        method = self.safe_value(methods, topic)
        if method is not None:
            method(client, message)

    def ping(self, client):
        # hollaex does not support built-in ws protocol-level ping-pong
        return {'op': 'ping'}

    def handle_pong(self, client, message):
        client.lastPong = self.milliseconds()
        return message
